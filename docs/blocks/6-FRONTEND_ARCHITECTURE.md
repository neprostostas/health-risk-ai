# Архітектура фронтенду HealthRisk.AI

Фронтенд проєкту HealthRisk.AI реалізований як Single Page Application (SPA) на чистому JavaScript без використання фреймворків (React, Vue, Angular). Це мінімалістичний, автономний та легкий клієнт, який забезпечує повну функціональність системи прогнозування ризиків здоров'я через динамічне перемикання секцій без перезавантаження сторінки.

## Загальний огляд фронтенду

Весь фронтенд організований як SPA на чистому JavaScript, що забезпечує швидку роботу, мінімальну залежність від зовнішніх бібліотек та повний контроль над поведінкою додатку. Головна ідея архітектури — мінімалістичний підхід без зайвих абстракцій, що дозволяє легко підтримувати та розширювати код.

**Організація index.html** передбачає один кореневий HTML-файл, який містить всі секції сторінок у прихованому стані. При завантаженні сторінки бекенд повертає цей HTML як контейнер, а JavaScript визначає, яку секцію відобразити на основі URL. Всі секції присутні в DOM з самого початку, але приховані через CSS-класи та атрибут `hidden`, що дозволяє швидко перемикатися між сторінками без додаткових HTTP-запитів.

**Завантаження модулів** відбувається через теги `<script>` у `<head>` HTML-документа. Бібліотеки завантажуються з CDN (Chart.js, Lucide, Navigo, jsPDF, xlsx-js-style), а власні модулі (i18n.js, app.js) завантажуються з сервера. Модуль i18n завантажується з атрибутом `defer`, щоб гарантувати його завантаження перед app.js, який залежить від нього.

**Головна ідея** архітектури — автономність та легкість. Фронтенд не залежить від складних систем збірки (Webpack, Vite), працює безпосередньо з браузером та використовує нативні API для всіх операцій. Це спрощує розробку, тестування та розгортання, оскільки не потрібно налаштовувати складні інструменти збірки.

## Структура файлів фронтенду

Фронтенд організований у директорії `src/service/web/` з чітким розділенням відповідальності між файлами.

**`index.html`** — кореневий HTML-файл, який містить структуру всієї сторінки: sidebar з навігацією, всі секції сторінок (форма прогнозування, історія, діаграми, профіль, чати, асистент тощо), модальні вікна, overlay-и та інші UI-компоненти. HTML містить всі необхідні елементи для роботи SPA, включаючи атрибути для локалізації (`data-i18n`), іконки Lucide (`data-lucide`) та структуровані дані для доступу через JavaScript.

**`app.js`** — основний файл логіки SPA, який містить всю бізнес-логіку фронтенду. Файл включає управління станом (authState, історія прогнозів, дані для діаграм), систему маршрутизації (ROUTE_SECTIONS, normalizePath, showSectionForPath, activateSection), роботу з API (fetch-запити, обробка відповідей), генерацію PDF-звітів, роботу з діаграмами Chart.js, інтеграцію з AI-асистентом, обробку форм та всю інтерактивність користувача. Файл має приблизно 14667 рядків коду та містить всі функції для роботи додатку.

**`app.css`** — глобальні стилі для всього додатку, які визначають вигляд всіх компонентів, тем (світла/темна), анімації, адаптивність та типографіку. CSS організований за принципом BEM-подібної методології з використанням модифікаторів та вкладених селекторів. Стилі включають CSS-змінні для тем, градієнти, тіні, переходи та всі візуальні ефекти.

**`i18n.js`** — модуль інтернаціоналізації, який забезпечує завантаження перекладів з JSON-файлів, динамічну підміну текстів на сторінці, локалізацію атрибутів (placeholder, aria-label, title) та підтримку кількох мов (українська, англійська). Модуль працює через глобальний об'єкт `window.i18n`, який надає методи для перекладу текстів та застосування локалізації до DOM-елементів.

**`locales/uk.json` та `locales/en.json`** — JSON-файли з перекладами для української та англійської мов. Кожен файл містить структуровані ключі для всіх текстів у додатку, включаючи форми, повідомлення, помилки, навігацію, діаграми, PDF-звіти та інші компоненти. Структура ключів ієрархічна (наприклад, `forms.targets.diabetes_present`, `history.empty.title`), що дозволяє легко організувати переклади.

**`fonts/DejaVuSans.ttf` та `fonts/DejaVuSans-Bold.ttf`** — шрифти для підтримки кирилиці у PDF-звітах. Шрифти завантажуються асинхронно при генерації PDF та вбудовуються у документ через jsPDF для коректного відображення українського тексту.

**`images/favicon.ico`** — іконка сайту, яка відображається у вкладці браузера.

**`data/analytics_summary.json`** — JSON-файл з даними для аналітики, який використовується для відображення статистики на сторінці діаграм.

## Архітектура SPA

SPA працює через один HTML-файл та динамічне перемикання секцій без перезавантаження сторінки. Всі секції присутні в DOM з самого початку, але приховані через CSS-класи та атрибут `hidden`.

**Принцип роботи SPA** полягає в тому, що при зміні URL через History API фронтенд не перезавантажується, а JavaScript визначає, яку секцію потрібно показати, та активує її через додавання CSS-класу `page--active` та видалення атрибута `hidden`. Всі інші секції приховуються через видалення класу `page--active` та додавання атрибута `hidden`.

**Секції відображаються/ховаються** через CSS-класи та атрибут `hidden`. Секція стає видимою, коли вона має клас `page--active` та не має атрибута `hidden`. Функція `activateSection()` забезпечує, що тільки одна секція активна одночасно, видаляючи клас `page--active` з усіх секцій та додаючи його тільки до цільової секції.

**Маршрути синхронізуються** через функцію `showSectionForPath()`, яка приймає шлях URL, нормалізує його через `normalizePath()`, визначає відповідну секцію через `getSectionByPath()` та активує її через `activateSection()`. Функція також оновлює URL через History API, щоб він відповідав активній секції.

**При зміні URL через History API** фронтенд не перезавантажується, а спрацьовує обробник події `popstate`, який викликає `syncRouteFromLocation()` для синхронізації стану з URL. Це дозволяє використовувати кнопки "Назад" та "Вперед" браузера для навігації по історії SPA.

**Бекенд повертає HTML лише як "контейнер"** — всі HTML-роути API завжди повертають один і той самий HTML-файл, незалежно від URL. JavaScript визначає, яку секцію показати на основі поточного URL при завантаженні сторінки або зміні маршруту.

**ROUTE_SECTIONS** — це об'єкт-мапінг, який зв'язує URL-шляхи з ID секцій у HTML. Наприклад, `/app` відповідає секції `page-form`, `/diagrams` відповідає секції `page-insights`, `/login` відповідає секції `page-login` тощо. Цей мапінг використовується функцією `getSectionByPath()` для визначення, яку секцію активувати для даного URL.

**normalizePath()** — функція, яка нормалізує URL-шляхи, видаляючи подвійні слеші, конвертуючи в нижній регістр (за винятком спеціальних маршрутів) та обробляючи аліаси (наприклад, `/` та `/form` мапляться на `/app`). Функція також обробляє спеціальні маршрути, такі як `/c/{chat_uuid}` для чатів та `/api-status/history` для історії API-status.

**syncRouteFromLocation()** — функція, яка синхронізує стан SPA з поточним URL у браузері. Вона викликається при завантаженні сторінки, зміні URL через History API або програмній зміні маршруту. Функція отримує поточний `pathname` з `window.location` та викликає `showSectionForPath()` для активації відповідної секції.

**activateSection()** — функція, яка активує конкретну секцію сторінки. Вона видаляє клас `page--active` з усіх секцій, додає його до цільової секції, видаляє атрибут `hidden`, оновлює активний стан навігації у sidebar та застосовує локалізацію до елементів секції. Функція також перевіряє автентифікацію для захищених секцій перед активацією.

## Система маршрутизації (Frontend Routing)

Система маршрутизації фронтенду забезпечує навігацію між сторінками SPA з підтримкою автентифікації та захисту маршрутів.

**Сторінки, які існують** включають:
- `/app` (або `/`, `/form`) — форма прогнозування ризиків (захищена)
- `/diagrams` — сторінка діаграм та аналітики (захищена)
- `/history` — історія прогнозів користувача (захищена)
- `/profile` — профіль користувача (захищена)
- `/assistant` — AI-асистент здоров'я (захищена)
- `/chats` — система чатів між користувачами (захищена)
- `/c/{chat_uuid}` — конкретний чат за UUID (захищена)
- `/reports` — сторінка звітів (захищена)
- `/api-status` — моніторинг стану API, БД та Ollama (захищена)
- `/api-status/history` — історія статусів системи (захищена)
- `/login` — сторінка входу (публічна)
- `/register` — сторінка реєстрації (публічна)
- `/forgot-password` — відновлення пароля (публічна)
- `/reset-password` — встановлення нового пароля через токен (публічна)
- `/about` — інформація про систему (публічна)

**Публічні сторінки** доступні без автентифікації: `/login`, `/register`, `/forgot-password`, `/reset-password`, `/about`. Всі інші сторінки вимагають автентифікації та перенаправляють на `/login`, якщо користувач не залогінений.

**Захищені сторінки** вимагають наявності валідного JWT-токена у LocalStorage та автентифікованого користувача в стані `authState`. При спробі доступу до захищеної сторінки без автентифікації користувач автоматично перенаправляється на `/login`.

**Визначення поточної сторінки** відбувається через функцію `getSectionByPath()`, яка аналізує `window.location.pathname`, нормалізує його через `normalizePath()` та визначає відповідну секцію через мапінг `ROUTE_SECTIONS`. Функція також обробляє спеціальні маршрути, такі як `/c/{chat_uuid}` для чатів.

**Guard-и для незалогіненого користувача** реалізовані через функцію `showSectionForPath()`, яка перевіряє наявність користувача перед активацією захищених секцій. Якщо користувач не залогінений та намагається отримати доступ до захищеної сторінки, викликається `handleUnauthorized()`, яка перенаправляє на `/login` та зберігає цільовий маршрут для повернення після входу.

**Guard-и для залогіненого користувача** дозволяють користувачу залишатися на своїй сторінці та навігувати між захищеними маршрутами без обмежень. Якщо залогінений користувач намагається отримати доступ до публічних сторінок (наприклад, `/login` або `/register`), він може залишитися на них, але зазвичай перенаправляється на `/app` для зручності.

**Функція `isPublicRoute()`** визначає, чи є маршрут публічним, перевіряючи, чи він присутній у списку публічних маршрутів. Ця функція використовується guard-ами для визначення, чи потрібна автентифікація для доступу до маршруту.

## Управління станом (State Management)

Управління станом у фронтенді реалізовано через JavaScript-об'єкти без використання спеціалізованих бібліотек (Redux, MobX тощо). Це спрощує архітектуру та забезпечує прямий контроль над станом.

**authState** — об'єкт, який зберігає стан автентифікації користувача. Він містить поля `token` (JWT-токен з LocalStorage), `user` (профіль користувача з API), `history` (кешована історія прогнозів для швидкого доступу) та `initialized` (прапорець, що вказує, чи завершена ініціалізація автентифікації). Стан оновлюється при вході, виході, оновленні профілю та завантаженні історії прогнозів.

**chatState** — стан для системи чатів, який включає вибраний чат (через URL `/c/{chat_uuid}`), список користувачів, список чатів, непрочитані повідомлення та стан завантаження. Стан оновлюється при створенні чатів, відправці повідомлень, читанні повідомлень та блокуванні користувачів.

**modelResultsState** — стан для результатів прогнозування, який зберігається у об'єкті `predictionStore` з ключами, що відповідають унікальним ідентифікаторам прогнозів. Кожен прогноз містить цільову змінну, ймовірність, категорію ризику, топ фактори та метадані моделі. Стан використовується для відображення результатів на формі, збереження в історії та передачі в AI-асистента.

**diagramState** — стан для діаграм, який включає кешовані дані аналітики (`analyticsCache`), статистику історії (`historyStatsCache`), стан ініціалізації діаграм (`insightsInitialized`) та об'єкт `dashboardCharts`, який зберігає екземпляри Chart.js для кожної діаграми. Стан оновлюється при завантаженні даних з API, оновленні діаграм та зміні розміру вікна.

**reportState** — стан для генерації звітів, який включає вибрані прогнози для експорту, формат звіту (PDF, Excel, CSV, JSON), налаштування теми (світла/темна) та стан генерації (overlay "Формуємо PDF-звіт"). Стан використовується для збереження параметрів експорту та відстеження процесу генерації.

**apiStatusState** — стан для моніторингу API, який включає статуси API, БД та Ollama, історію статусів для графіків (`apiStatusHistory`, `ollamaStatusHistory`), латентність запитів та помилки. Стан оновлюється періодично (кожні 10 секунд) через запити до ендпоінтів `/health`, `/system/database/stats` та `/assistant/health`.

**Локальне зберігання стану** виконується через LocalStorage для персистентних даних (JWT-токен, налаштування теми, стан sidebar, вибрані прогнози для асистента) та через JavaScript-змінні для тимчасових даних (кешовані результати API, стан UI-компонентів, анімації).

## Робота з API

Робота з API у фронтенді організована через функцію `apiCall()`, яка інкапсулює всі HTTP-запити та забезпечує централізовану обробку помилок, додавання токенів автентифікації та парсинг JSON-відповідей.

**fetch-запити** виконуються через нативний API `fetch()`, який підтримується всіма сучасними браузерами. Функція `apiCall()` приймає шлях ендпоінта, метод HTTP (GET, POST, PUT, DELETE, PATCH), тіло запиту (для POST/PUT) та опційні параметри (headers, timeout). Функція автоматично додає базовий URL (`API_BASE`, який за замовчуванням порожній для відносних шляхів), заголовок `Content-Type: application/json` для JSON-запитів та токен автентифікації з `authState.token` у заголовку `Authorization: Bearer <token>`.

**Централізована обробка помилок** реалізована через try/catch у функції `apiCall()` та перевірку статусів відповідей. При отриманні помилки 401 (неавторизований) фронтенд автоматично очищає токен, видаляє користувача зі стану та перенаправляє на `/login`. При інших помилках (400, 403, 404, 422, 500) функція повертає об'єкт з полями `error` та `detail` для відображення користувачу через систему нотифікацій.

**Надсилання даних на бекенд** відбувається через серіалізацію JavaScript-об'єктів у JSON через `JSON.stringify()` та передачу у тілі запиту. Фронтенд використовує Pydantic-схеми API для валідації даних перед відправкою, що забезпечує коректність запитів. Всі форми валідуються клієнтською стороною перед відправкою, що дозволяє швидко виявити помилки без очікування відповіді сервера.

**Обробка JSON-відповідей** виконується через `response.json()`, який автоматично парсить JSON-відповіді API. Фронтенд очікує структуровані відповіді згідно з Pydantic-схемами API (PredictResponse, PredictionHistoryResponse, ChatDetailResponse тощо) та обробляє їх відповідно до типу даних. Помилки парсингу обробляються через try/catch з поверненням зрозумілих повідомлень користувачу.

**Логіка роботи з токенами** включає збереження JWT-токена у LocalStorage під ключем `hr_auth_token` після успішного входу або реєстрації, автоматичне додавання токена до всіх API-запитів через заголовок `Authorization`, перевірку валідності токена при завантаженні сторінки через ендпоінт `/auth/me` та автоматичне видалення токена при помилці 401 або виході користувача.

**Робота з API-status** включає періодичні запити (кожні 10 секунд) до ендпоінтів `/health`, `/system/database/stats` та `/assistant/health` для отримання статусів компонентів системи. Фронтенд зберігає історію статусів для побудови графіків часу відгуку, відображає індикатори стану (онлайн/офлайн) та оновлює UI при зміні статусів. При недоступності API фронтенд відображає повідомлення про помилку підключення та дозволяє користувачу спробувати оновити статус вручну.

## Генерація PDF-звітів

Генерація PDF-звітів виконується повністю на фронтенді через бібліотеку jsPDF, що дозволяє створювати PDF-документи без завантаження на сервер.

**PDF генерується на фронтенді** через функцію `generatePDFReport()`, яка використовує jsPDF для створення документа, додавання тексту, таблиць, зображень та форматування. Функція приймає дані прогнозу (цільова змінна, ймовірність, категорія ризику, топ фактори, метадані) та опції (тема, формат) та генерує повний PDF-звіт з обкладинкою, основним контентом, графіками та рекомендаціями.

**Вставка діаграм** виконується через експорт графіків Chart.js у зображення через метод `toDataURL()` canvas-елементів. Фронтенд отримує всі доступні діаграми на сторінці (профіль, ризики, фактори, розподіли, кореляції, історія), конвертує їх у PNG-зображення з високою роздільною здатністю та вставляє у PDF через `doc.addImage()`. Діаграми масштабуються для вміщення на сторінку A4 з збереженням пропорцій.

**Рендеринг тексту** виконується через методи jsPDF `doc.text()`, `doc.setFont()`, `doc.setFontSize()`, `doc.setTextColor()` для додавання тексту з різними стилями, розмірами та кольорами. PDF підтримує кирилицю через завантаження шрифтів DejaVuSans (звичайний та жирний) з файлів `fonts/DejaVuSans.ttf` та `fonts/DejaVuSans-Bold.ttf`. Шрифти завантажуються асинхронно при першій генерації PDF та кешуються для подальшого використання.

**Якісне масштабування** забезпечується через обчислення розмірів елементів у міліметрах (формат A4: 210x297 мм) та автоматичне масштабування діаграм, зображень та тексту для вміщення на сторінку. Фронтенд використовує відступи (margins), внутрішні відступи (inner margins) та автоматичне перенесення тексту для оптимального розміщення контенту. Діаграми масштабуються з збереженням пропорцій та високої якості через встановлення високої роздільної здатності при експорті canvas.

**Overlay "Формуємо PDF-звіт"** відображається через функцію `setPdfExportOverlayVisible()`, яка показує напівпрозорий overlay з індикатором завантаження та текстом "Формуємо PDF-звіт..." під час генерації PDF. Overlay блокує інтерфейс, щоб користувач не міг взаємодіяти з додатком під час генерації, та автоматично ховається після завершення або помилки.

**Відключення скролу** виконується через додавання класу до body, який встановлює `overflow: hidden` під час генерації PDF, щоб запобігти прокрутці сторінки. Після завершення генерації клас видаляється, і скрол відновлюється.

**Отримання даних з API** відбувається перед генерацією PDF через завантаження даних прогнозу з історії (`/users/history`) або використання поточних результатів з форми. Фронтенд також завантажує статистику для діаграм (`/users/history/stats`) та метадані моделей (`/metadata`) для включення в PDF. Всі дані кешуються для швидкого доступу при повторній генерації звіту.

## Діаграми (Charts)

Діаграми у фронтенді реалізовані через бібліотеку Chart.js, яка забезпечує інтерактивні, адаптивні та високоякісні графіки для візуалізації даних.

**Використовувана бібліотека** — Chart.js версії 4.4.6, яка завантажується з CDN через тег `<script>` у HTML. Бібліотека підтримує різні типи діаграм (лінійні, стовпчасті, кругові, діаграми розсіювання, теплокарти), анімації, інтерактивність (tooltips, легенди, масштабування) та експорт у зображення.

**Підготовка сирих даних** виконується через завантаження даних з API (`/users/history/stats` для статистики історії, `/metadata` для метаданих, `/users/history` для деталей прогнозів) та обробку їх у формат, зручний для Chart.js. Фронтенд групує дані за категоріями (цільові змінні, категорії ризику, моделі, дати), обчислює агрегати (суми, середні, розподіли) та формує масиви для осей X та Y діаграм.

**Типи діаграм** включають:
- **Ризик-моделі** — стовпчасті діаграми, які показують розподіл прогнозів по категоріях ризику (низький, помірний, високий) для кожної цільової змінної (діабет, ожиріння) та моделі
- **Розподіли** — гістограми та кругові діаграми, які показують розподіл значень ознак (ІМТ, глюкоза, холестерин, артеріальний тиск) з датасету NHANES
- **Кореляції** — теплокарти, які показують кореляційну матрицю між числовими ознаками та цільовими змінними
- **Розподіл віку** — стовпчасті діаграми, які показують розподіл прогнозів по віковим групам та зв'язок віку з ризиками
- **Часові діаграми історії** — лінійні діаграми, які показують зміну ймовірностей ризиків у часі на основі історії прогнозів користувача

**Оновлення діаграм** виконується автоматично при зміні даних (нові прогнози, оновлення історії, зміна фільтрів) через функцію `upsertDashboardChart()`, яка створює новий екземпляр Chart.js або оновлює існуючий. Функція зберігає посилання на всі діаграми у об'єкті `dashboardCharts` для швидкого доступу та видалення при необхідності.

**Експорт діаграм у PDF** виконується через конвертацію canvas-елементів у зображення через метод `toDataURL('image/png')` з високою роздільною здатністю. Фронтенд обходить всі діаграми на сторінці, експортує їх у PNG, масштабує для вміщення на сторінку A4 та вставляє у PDF через `doc.addImage()`. Діаграми зберігають високу якість завдяки високій роздільній здатності експорту.

**Перерисовка при зміні розміру canvas** виконується автоматично через обробник події `resize` вікна браузера. Chart.js автоматично адаптує розмір діаграм до розміру canvas-елементів, але фронтенд також може викликати метод `resize()` для примусового оновлення діаграм при зміні розміру контейнерів.

## AI-асистент (Ollama Frontend UI)

Інтерфейс AI-асистента реалізований як чат-інтерфейс, який інтегрується з локальним Ollama сервером через API для генерації персоналізованих рекомендацій щодо здоров'я.

**Інтерфейс чату** включає область повідомлень з історією діалогу, поле введення для повідомлень користувача, кнопку відправки та індикатор "Асистент думає..." під час генерації відповіді. Повідомлення відображаються у вигляді карток з різними стилями для повідомлень користувача та асистента, включаючи аватари, timestamps та форматування тексту.

**Виклик API для Ollama** виконується через ендпоінт `/assistant/chat`, який приймає повідомлення користувача, опційний `prediction_id` для контексту конкретного прогнозу та мову (`uk` або `en`). Фронтенд відправляє POST-запит з JSON-тілом, отримує відповідь асистента та відображає її в чаті. Всі повідомлення зберігаються в історії через ендпоінт `/assistant/history`.

**Система блокування користувача** не стосується AI-асистента безпосередньо, але фронтенд підтримує блокування інших користувачів у системі чатів через ендпоінти `/api/chats/users` та функцію блокування в профілі користувача. Блокування впливає на можливість створення чатів та відправки повідомлень між користувачами.

**UI з останніми повідомленнями** відображає історію повідомлень з асистентом через завантаження даних з ендпоінта `/assistant/history`. Фронтенд зберігає вибраний прогноз для контексту (`assistantSelectedPredictionId`) та останній timestamp (`assistantLatestTimestamp`) у LocalStorage для відновлення стану при перезавантаженні сторінки.

**Анімація "Перевірка..." для Ollama** відображається через індикатор з текстом "Перевірка" та анімованими крапками, які додаються поступово (".", "..", "...") під час очікування відповіді від Ollama. Анімація запускається перед відправкою запиту та зупиняється при отриманні відповіді або помилки.

**Статуси AI** відображаються на сторінці `/api-status` через ендпоінт `/assistant/health`, який перевіряє доступність Ollama сервера, вимірює латентність запитів та повертає статус (online, offline, timeout, error). Фронтенд відображає індикатор стану, графік часу відгуку та детальну інформацію про помилки, якщо вони виникають.

**Логіка автопрокрутки історії чату** виконується автоматично при додаванні нових повідомлень через прокрутку контейнера повідомлень до останнього елемента. Фронтенд використовує `scrollIntoView()` або встановлення `scrollTop` для плавної прокрутки до нового повідомлення.

## UI/UX архітектура

UI/UX архітектура фронтенду організована через систему секцій, компонентів, анімацій та адаптивності для забезпечення зручного та інтуїтивного інтерфейсу.

**Система секцій і сторінок** включає всі сторінки додатку як окремі секції в HTML з унікальними ID (наприклад, `page-form`, `page-history`, `page-assistant`). Секції приховані за замовчуванням через CSS-класи та атрибут `hidden`, а активуються через додавання класу `page--active` та видалення атрибута `hidden`. Тільки одна секція активна одночасно, що забезпечує чітку навігацію та зменшує навантаження на DOM.

**Використання модальних вікон** включає модальні діалоги для підтвердження дій (видалення прогнозів, очищення історії, вихід з акаунту), налаштувань (тема, мова), інформації (про систему, про ризики) та помилок. Модальні вікна реалізовані через overlay з напівпрозорим фоном та центрованим контейнером з контентом. Вікна закриваються при кліку поза ними, натисканні клавіші Escape або кнопки закриття.

**Анімації** включають плавні переходи між секціями (fade in/out), анімації завантаження (spinner, skeleton screens), анімації появи елементів (slide in, fade in), анімації індикаторів стану (пульсація, обертання) та анімації графіків Chart.js (поява стовпців, ліній, точок). Анімації реалізовані через CSS transitions та animations для плавності та продуктивності.

**Loader-и** відображаються під час завантаження даних з API, генерації PDF, відправки повідомлень до асистента та інших асинхронних операцій. Loader-и включають spinner з обертанням, skeleton screens для контенту, що завантажується, та індикатори прогресу для довгих операцій (генерація PDF). Loader-и автоматично ховаються після завершення операції або помилки.

**Tooltip-и** відображаються при наведенні на елементи з атрибутом `title` або через спеціальні компоненти tooltip для складних підказок. Tooltip-и показують додаткову інформацію про елементи інтерфейсу (кнопки, іконки, індикатори), пояснення термінів, підказки для форм та інструкції для користувачів.

**Компоненти чату** включають список чатів з останніми повідомленнями, детальний вигляд чату з історією повідомлень, поле введення з підтримкою багаторядкового тексту, індикатори непрочитаних повідомлень, статуси користувачів (онлайн/офлайн) та можливість блокування користувачів. Компоненти реалізовані через HTML-структури з CSS-стилізацією та JavaScript для інтерактивності.

**Компоненти форм** включають поля введення з валідацією в реальному часі, вибіркові списки (select), радіо-кнопки, чекбокси, кнопки відправки з індикаторами завантаження та повідомлення про помилки. Форми валідуються перед відправкою через JavaScript та відображають помилки поруч з полями або через нотифікації.

**Компоненти графіків** включають контейнери для діаграм Chart.js з адаптивними розмірами, легенди, tooltip-и при наведенні, кнопки експорту та фільтри для зміни відображених даних. Графіки автоматично адаптуються до розміру контейнерів та оновлюються при зміні даних.

**API-status tabs** включають вкладки для перемикання між різними компонентами системи (API, БД, Ollama), індикатори стану для кожного компонента, графіки часу відгуку, детальну статистику та кнопки оновлення статусу. Вкладки реалізовані через HTML-структуру з CSS для стилізації та JavaScript для перемикання та оновлення контенту.

**Адаптивність** забезпечується через CSS media queries для різних розмірів екранів (мобільні, планшети, десктопи), гнучкі розміри (flexbox, grid), адаптивні шрифти та відступи, згортання sidebar на мобільних пристроях та оптимізацію діаграм для малих екранів. Фронтенд працює коректно на всіх типах пристроїв завдяки responsive design.

## Стилі

Стилі фронтенду організовані у файлі `app.css` з використанням CSS-змінних, BEM-подібної методології та систематичної структури селекторів.

**Архітектура app.css** включає глобальні стилі (reset, нормалізація, типографіка), CSS-змінні для тем (світла/темна), стилі компонентів (sidebar, forms, charts, modals, tooltips), стилі секцій сторінок, анімації та transitions, адаптивні стилі (media queries) та утилітарні класи (visually-hidden, спінер-и, badges).

**Структура селекторів** організована за принципом BEM-подібної методології з використанням подвійного підкреслення (`__`) для елементів та подвійного дефісу (`--`) для модифікаторів. Наприклад, `.sidebar__nav`, `.nav-item--active`, `.page--active`. Це забезпечує чітку ієрархію стилів та уникнення конфліктів селекторів.

**Використання BEM-подібної системи** дозволяє легко знаходити стилі для конкретних компонентів, уникати вкладених селекторів та забезпечує модульність стилів. Кожен компонент має свій блок (наприклад, `.sidebar`, `.form`, `.chart`), елементи всередині блоку (наприклад, `.sidebar__nav`, `.form__input`) та модифікатори для варіацій (наприклад, `.nav-item--active`, `.button--primary`).

**Нормалізація** включає reset стилів браузера (margin, padding, box-sizing), нормалізацію типографіки (font-family, line-height, color), обробку прихованих елементів (`[hidden]`) та доступності (`.visually-hidden` для screen readers). Нормалізація забезпечує консистентність відображення у різних браузерах.

**UI-теми (світла/темна)** реалізовані через CSS-змінні, які змінюються залежно від класу `theme-light` або `theme-dark` на елементі `<body>`. Тема зберігається у LocalStorage та відновлюється при завантаженні сторінки. Перемикання теми виконується через кнопку у sidebar, яка змінює клас на body та оновлює всі CSS-змінні (кольори, градієнти, тіні, прозорість).

**Логіка layout-а** включає flexbox для горизонтального та вертикального вирівнювання, grid для складних сіток (якщо використовується), абсолютне позиціювання для overlay-ів та модальних вікон, sticky positioning для sidebar та headers та адаптивні розміри через відсотки та viewport units (vw, vh). Layout забезпечує коректне відображення на всіх розмірах екранів.

## Система локалізації

Система локалізації фронтенду реалізована через власний модуль `i18n.js`, який забезпечує завантаження перекладів з JSON-файлів, динамічну підміну текстів та підтримку кількох мов.

**JSON-файли локалізації** зберігаються у директорії `locales/` та включають `uk.json` (українська) та `en.json` (англійська). Кожен файл містить структуровані ключі для всіх текстів у додатку, організовані за функціональними групами (forms, history, charts, assistant, errors тощо). Структура ключів ієрархічна (наприклад, `forms.targets.diabetes_present`, `history.empty.title`), що дозволяє легко організувати та знаходити переклади.

**Ключі** використовуються через метод `window.i18n.t()`, який приймає ключ перекладу та опційні змінні для інтерполяції (наприклад, `i18n.t('history.count', {count: 5})`). Ключі можуть бути вкладеними через крапки (наприклад, `forms.targets.diabetes_present`) або плоскими (наприклад, `login.title`). Модуль автоматично знаходить переклад у вкладених об'єктах та повертає fallback (український текст або сам ключ), якщо переклад відсутній.

**Динамічна підміна текстів** виконується через атрибут `data-i18n` на HTML-елементах, який містить ключ перекладу. Функція `applyTranslations()` обходить всі елементи з цим атрибутом, знаходить переклад через `i18n.t()` та встановлює його як textContent елемента. Підміна виконується при завантаженні сторінки, зміні мови та активації нових секцій.

**Локалізація атрибутів** включає підтримку `data-i18n-title` для атрибута `title`, `data-i18n-placeholder` для атрибута `placeholder`, `data-i18n-aria-label` для атрибута `aria-label` та інших атрибутів через префікс `data-i18n-`. Модуль автоматично визначає тип атрибута та встановлює відповідний переклад. Це забезпечує локалізацію не тільки видимого тексту, але й допоміжних атрибутів для доступності та UX.

**План масштабування на нові мови** передбачає створення нового JSON-файлу у директорії `locales/` з тією ж структурою ключів, що й `uk.json`, додавання коду мови до масиву `SUPPORTED_LANGUAGES` у `i18n.js`, додавання кнопки перемикання мови у UI (якщо потрібно) та тестування перекладів. Модуль автоматично завантажує переклади для нової мови та використовує українську як fallback для відсутніх ключів.

## Тести для фронтенду (архітектурний огляд)

Тестування фронтенду організовано через структуру тестів у директорії `tests/frontend/` з розділенням на unit, integration та e2e тести.

**Що буде тестуватися** включає функції маршрутизації (normalizePath, getSectionByPath, showSectionForPath, activateSection), функції роботи з API (apiCall, обробка помилок, додавання токенів), функції генерації PDF (generatePDFReport, експорт діаграм, форматування), функції роботи з діаграмами (створення Chart.js, оновлення, експорт), функції локалізації (i18n.t, applyTranslations), управління станом (authState, оновлення стану) та UI-компоненти (форми, модальні вікна, нотифікації).

**Snapshot-тести** використовуються для перевірки структури HTML після активації секцій, вмісту PDF-документів після генерації, структури JSON-відповідей API та стану DOM після різних операцій. Snapshot-тести забезпечують, що структура не змінюється неочікувано при рефакторингу.

**Інтеграційні сценарії** включають повний цикл прогнозування (введення даних, відправка на API, відображення результатів, збереження в історії), повний цикл генерації PDF (вибір прогнозу, генерація, завантаження), повний цикл роботи з асистентом (відправка повідомлення, отримання відповіді, відображення в чаті), навігацію між сторінками (перехід між секціями, збереження стану, відновлення після перезавантаження) та автентифікацію (вхід, вихід, оновлення профілю).

**Mock API** використовується для імітації відповідей API без реального сервера через створення mock-об'єктів для `fetch()`, які повертають тестові дані згідно зі сценаріями тестів. Mock API дозволяє тестувати фронтенд ізольовано від бекенду та перевіряти обробку різних сценаріїв (успішні відповіді, помилки, таймаути).

**Тестування лоадерів, секцій, рендерингу** включає перевірку відображення loader-ів під час завантаження, приховування/показу секцій при навігації, коректного рендерингу контенту після завантаження даних, оновлення UI при зміні стану та обробки помилок рендерингу. Тести перевіряють, що UI коректно реагує на зміни стану та відображає контент у правильний час.

**Тестування поведінки без фреймворків** виконується через нативні API браузера (DOM, Fetch, History) без використання тестових утиліт фреймворків. Тести використовують jsdom для емуляції DOM у Node.js або реальний браузер через Puppeteer/Playwright для e2e тестів. Це забезпечує тестування реальної поведінки коду без додаткових абстракцій.

## Майбутні покращення

Фронтенд має потенціал для покращень у різних напрямках для підвищення продуктивності, підтримуваності та функціональності.

**Можливість переходу на React / Vue** розглядається для покращення структури коду, компонентності, управління станом та підтримуваності. Перехід на фреймворк дозволить розбити великий файл `app.js` на менші компоненти, використовувати вбудовані інструменти для управління станом (React Context, Vuex) та спростити тестування через компонентний підхід. Однак це вимагатиме рефакторингу всього коду та додавання системи збірки.

**SSR (Server-Side Rendering)** може бути додано для покращення SEO, швидкості першого рендерингу та доступності для пошукових систем. SSR дозволить серверу генерувати HTML з даними перед відправкою клієнту, що покращить час завантаження та індексацію контенту пошуковими системами.

**Client-side caching** може бути додано через Service Workers для кешування статичних ресурсів (HTML, CSS, JS, зображення), кешування відповідей API для швидкого доступу та офлайн-режиму для базових функцій. Caching покращить продуктивність при повторних відвідуваннях та дозволить працювати без інтернету для деяких функцій.

**Оптимізація PDF** може включати лазерне завантаження шрифтів (завантаження тільки при потребі), оптимізацію розміру зображень діаграм (стиснення, зменшення роздільної здатності для менших файлів), покращення швидкості генерації (асинхронна обробка, web workers) та підтримку інших форматів експорту (DOCX, HTML).

**Оптимізація діаграм** може включати віртуалізацію для великих наборів даних (відображення тільки видимих елементів), лазерне завантаження даних (завантаження тільки необхідних діаграм), оптимізацію продуктивності Chart.js (зменшення кількості точок даних, використання спрощених типів діаграм) та покращення якості експорту (вища роздільна здатність, векторні формати).

**Локалізація** може бути розширена через додавання нових мов (польська, німецька, французька), покращення системи перекладів (підтримка множини, форматування дат/чисел), автоматичне визначення мови браузера та синхронізацію мови з бекендом для Ollama.

**Сервіс-воркери** можуть бути додані для фонової синхронізації даних (оновлення історії, статусів), push-нотифікацій для важливих подій (нові повідомлення, оновлення статусів), офлайн-режиму для базових функцій (перегляд історії, локальні прогнози) та покращення продуктивності через фонову обробку (генерація PDF, обробка даних).

