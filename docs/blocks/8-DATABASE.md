# База даних у проєкті HealthRisk.AI

База даних у проєкті HealthRisk.AI виконує роль центрального сховища стану для вебінтерфейсу та API, зберігаючи дані користувачів, історію прогнозів, чати, повідомлення та іншу інформацію, необхідну для роботи системи.

## Загальний огляд

**Тип БД** — у проєкті використовується SQLite, легка файлова база даних, яка не вимагає окремого сервера та ідеально підходить для розробки та середніх навантажень. SQLite зберігає всі дані в одному файлі на диску, що спрощує розгортання та резервне копіювання.

**Основні задачі БД** включають:
- **Користувачі та аутентифікація** — зберігання профілів користувачів, хешів паролів, токенів для відновлення пароля, аватари, налаштування профілю
- **Історія прогнозів** — збереження всіх прогнозувань ризиків здоров'я, виконаних користувачами, включаючи вхідні параметри, результати, використані моделі та топ фактори впливу
- **Чати й повідомлення** — зберігання чатів між користувачами, повідомлень у чатах, статусів прочитання, закріплення чатів, порядку відображення
- **AI-асистент** — зберігання історії повідомлень з AI-асистентом, зв'язків з конкретними прогнозами для контексту
- **Блокування користувачів** — зберігання інформації про блокування між користувачами для запобігання створенню чатів та відправці повідомлень
- **Системні статуси** — база даних використовується для перевірки стану системи через підрахунок записів, розміру БД та активності

**БД є центральним сховищем стану** — всі дані, необхідні для роботи вебінтерфейсу та API, зберігаються в базі даних. Фронтенд отримує дані через API-ендпоінти, які читають з БД, а всі зміни (створення користувачів, збереження прогнозів, відправка повідомлень) записуються в БД для персистентності.

## Технології та інструменти для роботи з БД

**Бібліотеки для роботи з БД** включають SQLModel як ORM (Object-Relational Mapping), який поєднує Pydantic для валідації та SQLAlchemy для роботи з БД. SQLModel дозволяє визначати моделі, які використовуються і для валідації API, і для роботи з БД, що забезпечує консистентність даних. SQLAlchemy використовується як низькорівневий шар для створення engine, сесій та виконання SQL-запитів. Драйвер БД — вбудований sqlite3 для Python, який не потребує додаткових залежностей.

**Основний код роботи з БД** знаходиться у наступних модулях:
- **`src/service/db.py`** — модуль для налаштування підключення до БД, створення engine, функції ініціалізації БД (`init_db()`), міграції (`migrate_add_missing_columns()`), отримання сесій (`get_session()`, `session_scope()`)
- **`src/service/models.py`** — ORM-моделі для всіх таблиць БД, які визначають структуру таблиць, поля, типи даних, обмеження, індекси, foreign keys та relationships між таблицями
- **`src/service/repositories.py`** — репозиторійний шар для абстракції роботи з БД, який містить функції для CRUD операцій (створення, читання, оновлення, видалення) для всіх сутностей

**Організація підключення до БД** реалізована через SQLAlchemy engine, який створюється один раз при імпорті модуля `db.py` та використовується для всіх підключень. Engine налаштований з `echo=False` (без логування SQL-запитів) та `connect_args={"check_same_thread": False}` для підтримки багатопотоковості в ASGI. При кожному HTTP-запиті створюється нова сесія через `get_session()`, яка використовується як dependency у FastAPI ендпоінтах через `Depends(get_session)`. Сесія автоматично закривається після завершення обробки запиту через контекстний менеджер.

**Life-cycle сесій у запитах** включає створення сесії при початку обробки HTTP-запиту через `get_session()`, використання сесії для виконання SQL-запитів через репозиторії, commit транзакції при успішному завершенні операцій, rollback транзакції при помилках та автоматичне закриття сесії при завершенні обробки запиту. Це забезпечує ізоляцію транзакцій між різними запитами та коректну обробку помилок.

## Фізичне розташування БД

**Де зберігається файл БД** — база даних зберігається у файлі `data/app.db` відносно кореня проєкту. Директорія `data/` створюється автоматично при першому запуску, якщо вона не існує, через `DATA_DIR.mkdir(parents=True, exist_ok=True)` у модулі `db.py`. Повний шлях до файлу формується як `sqlite:///data/app.db` у форматі SQLAlchemy connection string.

**Створення БД автоматично** — база даних створюється автоматично при першому запуску додатку через функцію `init_db()`, яка викликається в `lifespan` контекстному менеджері FastAPI при startup. Функція перевіряє наявність таблиць та створює їх, якщо вони не існують, через `SQLModel.metadata.create_all(bind=engine)`. Після створення таблиць виконується міграція для додавання відсутніх колонок через `migrate_add_missing_columns()`.

**Скрипти для ініціалізації / міграцій** — ініціалізація виконується автоматично через `init_db()`, але міграції реалізовані через функцію `migrate_add_missing_columns()`, яка перевіряє наявність колонок у таблицях та додає відсутні через `ALTER TABLE`. Міграції виконуються при кожному запуску додатку, що забезпечує актуальність схеми БД. Наразі немає окремих скриптів для міграцій, але в майбутньому можна додати систему міграцій (наприклад, Alembic) для більш складних змін схеми.

## Основні таблиці та їх призначення

База даних містить сім основних таблиць, які забезпечують повну функціональність системи.

### Таблиця користувачів (user)

**Назва таблиці** — `user` (визначається через SQLModel клас `User`).

**Основні поля**:
- `id` — первинний ключ (автоінкрементний integer)
- `email` — електронна пошта користувача (унікальний, індексований, обов'язковий)
- `hashed_password` — хеш пароля через bcrypt (обов'язковий)
- `display_name` — ім'я для відображення (обов'язковий)
- `first_name` — ім'я користувача (опційний)
- `last_name` — прізвище користувача (опційний)
- `date_of_birth` — дата народження (опційний, datetime)
- `gender` — стать користувача (опційний, рядок: male/female/other)
- `avatar_url` — URL завантаженого аватару (опційний)
- `avatar_type` — тип аватару: "generated" (за замовчуванням) або "uploaded" (обов'язковий)
- `avatar_color` — колір для згенерованого аватару (опційний)
- `is_active` — чи активний акаунт (boolean, за замовчуванням True)
- `created_at` — дата створення акаунта (datetime, автоматично)
- `updated_at` — дата останнього оновлення (datetime, автоматично)

**Призначення** — зберігання акаунтів користувачів, аутентифікація через email та пароль, зберігання профільної інформації, управління аватарами, контроль активності акаунтів. Таблиця є центральною для всіх зв'язків з іншими таблицями через foreign keys.

### Таблиця історії прогнозів (predictionhistory)

**Назва таблиці** — `predictionhistory` (визначається через SQLModel клас `PredictionHistory`).

**Поля**:
- `id` — первинний ключ (автоінкрементний integer)
- `user_id` — зовнішній ключ до таблиці `user` (індексований, обов'язковий)
- `target` — цільова змінна прогнозування: "diabetes_present" або "obesity_present" (обов'язковий)
- `model_name` — назва використаної моделі ML (опційний)
- `probability` — ймовірність позитивного класу (float, 0-1, обов'язковий)
- `risk_bucket` — категорія ризику: "low", "medium" або "high" (обов'язковий)
- `inputs` — вхідні параметри прогнозу у форматі JSON (обов'язковий), включає всі ознаки (вік, стать, ІМТ, тиск, глюкоза, холестерин), топ фактори впливу, метадані
- `created_at` — дата та час створення прогнозу (datetime, автоматично)

**Призначення** — логування всіх прогнозувань ризиків для кожного користувача, побудова історії прогнозів для відображення на фронтенді, використання в AI-асистенті для контексту, аналіз трендів ризиків у часі, статистика для діаграм та звітів.

### Таблиця чатів (chat)

**Назва таблиці** — `chat` (визначається через SQLModel клас `Chat`).

**Поля**:
- `id` — первинний ключ (автоінкрементний integer)
- `uuid` — унікальний ідентифікатор чату для URL (унікальний, індексований, автоматично генерується через UUID)
- `user1_id` — зовнішній ключ до таблиці `user` (індексований, обов'язковий) — ID першого учасника
- `user2_id` — зовнішній ключ до таблиці `user` (індексований, обов'язковий) — ID другого учасника
- `created_at` — дата створення чату (datetime, автоматично)
- `updated_at` — дата останнього оновлення (datetime, автоматично, оновлюється при додаванні повідомлень)
- `is_pinned` — чи закріплений чат (boolean, за замовчуванням False)
- `order` — порядок відображення чату для drag and drop (integer, за замовчуванням 0)

**Призначення** — зберігання чатів між двома користувачами, управління порядком відображення чатів, закріплення важливих чатів, відстеження останньої активності через `updated_at`. Кожен чат унікальний для пари користувачів (не можна створити два чати між однією парою).

### Таблиця повідомлень (chatmessage)

**Назва таблиці** — `chatmessage` (визначається через SQLModel клас `ChatMessage`).

**Поля**:
- `id` — первинний ключ (автоінкрементний integer)
- `chat_id` — зовнішній ключ до таблиці `chat` (індексований, обов'язковий)
- `sender_id` — зовнішній ключ до таблиці `user` (індексований, обов'язковий) — ID відправника
- `content` — текст повідомлення (Text, обов'язковий)
- `created_at` — дата та час відправки (datetime, автоматично)
- `read_at` — дата та час прочитання повідомлення (datetime, опційний, None означає непрочитане)

**Призначення** — зберігання повідомлень у чатах між користувачами, відстеження статусу прочитання для підрахунку непрочитаних повідомлень, побудова історії діалогів, сортування повідомлень за часом для відображення на фронтенді.

### Таблиця повідомлень AI-асистента (assistantmessage)

**Назва таблиці** — `assistantmessage` (визначається через SQLModel клас `AssistantMessage`).

**Поля**:
- `id` — первинний ключ (автоінкрементний integer)
- `user_id` — зовнішній ключ до таблиці `user` (індексований, обов'язковий)
- `role` — роль автора: "user" (користувач) або "assistant" (AI-асистент) (обов'язковий)
- `content` — текст повідомлення (Text, обов'язковий)
- `created_at` — дата та час створення (datetime, автоматично)
- `prediction_id` — зовнішній ключ до таблиці `predictionhistory` (опційний) — зв'язок з конкретним прогнозом для контексту

**Призначення** — зберігання історії повідомлень з AI-асистентом для кожного користувача, відновлення контексту діалогу при наступних запитах, зв'язок з конкретними прогнозами для більш точних рекомендацій, побудова історії чату для відображення на фронтенді.

### Таблиця заблокованих користувачів (userblock)

**Назва таблиці** — `userblock` (визначається через SQLModel клас `UserBlock`).

**Поля**:
- `id` — первинний ключ (автоінкрементний integer)
- `user_id` — зовнішній ключ до таблиці `user` (індексований, обов'язковий) — ID користувача, який заблокував
- `blocked_user_id` — зовнішній ключ до таблиці `user` (індексований, обов'язковий) — ID заблокованого користувача
- `created_at` — дата блокування (datetime, автоматично)

**Призначення** — зберігання інформації про блокування між користувачами. Якщо `user_id` заблокував `blocked_user_id`, то вони не можуть створювати нові чати, відправляти повідомлення один одному та бачитися в активних чатах. Таблиця має унікальний індекс на парі `(user_id, blocked_user_id)` для запобігання дублюванню блокувань. Блокування одностороннє — якщо користувач A заблокував користувача B, це не означає, що B заблокував A.

### Таблиця токенів відновлення пароля (passwordresettoken)

**Назва таблиці** — `passwordresettoken` (визначається через SQLModel клас `PasswordResetToken`).

**Поля**:
- `id` — первинний ключ (автоінкрементний integer)
- `user_id` — зовнішній ключ до таблиці `user` (індексований, обов'язковий)
- `token` — унікальний токен для відновлення пароля (унікальний, індексований, обов'язковий)
- `expires_at` — час закінчення токену (datetime, обов'язковий)
- `used` — чи використано токен (boolean, за замовчуванням False)
- `created_at` — дата створення токену (datetime, автоматично)

**Призначення** — зберігання токенів для відновлення пароля, які генеруються при запиті "забув пароль" та відправляються на email користувача. Токени мають термін дії та можуть бути використані тільки один раз. Після використання поле `used` встановлюється в True, що запобігає повторному використанню токену.

## Звʼязки між таблицями

База даних має чітку структуру зв'язків між таблицями, яка забезпечує цілісність даних та ефективні запити.

**Звʼязок User ↔ PredictionHistory (один-до-багатьох)** — один користувач може мати багато записів в історії прогнозів. Кожен запис історії пов'язаний з одним користувачем через `user_id`. Зв'язок реалізований через foreign key `user_id` в таблиці `predictionhistory` та relationship `history` в моделі `User`. Це дозволяє легко отримувати всі прогнози користувача та забезпечує автоматичне видалення записів при видаленні користувача (якщо налаштовано CASCADE).

**Звʼязок User ↔ AssistantMessage (один-до-багатьох)** — один користувач може мати багато повідомлень з AI-асистентом. Кожне повідомлення пов'язане з одним користувачем через `user_id`. Зв'язок реалізований через foreign key `user_id` в таблиці `assistantmessage`. Це дозволяє зберігати окрему історію діалогу з асистентом для кожного користувача.

**Звʼязок User ↔ Chat (багато-до-багатьох через проміжну таблицю)** — користувачі можуть мати багато чатів, а кожен чат пов'язаний з двома користувачами через `user1_id` та `user2_id`. Зв'язок реалізований через два foreign keys в таблиці `chat`. Це дозволяє кожному користувачу мати багато чатів з різними користувачами, а кожен чат унікальний для пари користувачів.

**Звʼязок Chat ↔ ChatMessage (один-до-багатьох)** — кожен чат пов'язаний з багатьма повідомленнями. Кожне повідомлення пов'язане з одним чатом через `chat_id`. Зв'язок реалізований через foreign key `chat_id` в таблиці `chatmessage` та relationship `messages` в моделі `Chat`. Це дозволяє легко отримувати всі повідомлення чату та забезпечує автоматичне видалення повідомлень при видаленні чату (якщо налаштовано CASCADE).

**Звʼязок ChatMessage ↔ User (багато-до-одного)** — кожне повідомлення пов'язане з одним відправником через `sender_id`. Зв'язок реалізований через foreign key `sender_id` в таблиці `chatmessage` та relationship `sender` в моделі `ChatMessage`. Це дозволяє легко отримувати інформацію про відправника повідомлення.

**Звʼязок AssistantMessage ↔ PredictionHistory (багато-до-одного, опційний)** — повідомлення асистента можуть бути пов'язані з конкретним прогнозом через `prediction_id` для контексту. Зв'язок опційний (може бути None), що дозволяє повідомленням існувати без зв'язку з прогнозом. Це дозволяє AI-асистенту використовувати контекст конкретного прогнозу для більш точних рекомендацій.

**Звʼязок User ↔ UserBlock (один-до-багатьох, двоспрямований)** — таблиця блокувань з'єднує користувача, який блокує (`user_id`), і того, кого заблоковано (`blocked_user_id`). Один користувач може заблокувати багато інших користувачів, а один користувач може бути заблокований багатьма іншими. Зв'язок реалізований через два foreign keys в таблиці `userblock`. Унікальний індекс на парі `(user_id, blocked_user_id)` запобігає дублюванню блокувань.

**Звʼязок User ↔ PasswordResetToken (один-до-багатьох)** — один користувач може мати багато токенів для відновлення пароля (наприклад, якщо запитує відновлення кілька разів). Кожен токен пов'язаний з одним користувачем через `user_id`. Зв'язок реалізований через foreign key `user_id` в таблиці `passwordresettoken`. Токени мають термін дії та можуть бути використані тільки один раз.

## Управління транзакціями

Управління транзакціями забезпечує цілісність даних та коректну обробку помилок.

**Як відкривається сесія для запиту** — при кожному HTTP-запиті до API створюється нова сесія через `get_session()`, яка використовується як dependency у FastAPI ендпоінтах через `Depends(get_session)`. Функція `get_session()` є генератором, який створює сесію через `Session(engine)`, передає її в ендпоінт через `yield`, та автоматично закриває сесію після завершення обробки запиту через контекстний менеджер. Це забезпечує, що кожен запит має свою ізольовану сесію.

**Як commit/rollback організовано** — commit транзакції виконується явно через `session.commit()` після успішного виконання операцій (створення користувача, збереження прогнозу, відправка повідомлення). Rollback виконується автоматично при виникненні винятків через try/catch блоки у репозиторіях та ендпоінтах. При помилках (наприклад, `IntegrityError` для дублювання email, `SQLAlchemyError` для загальних помилок БД) виконується `session.rollback()` для скасування змін у транзакції, після чого повертається `HTTPException` з відповідним статус-кодом.

**Контекстні менеджери / dependency injection для сесій** — сесії управляються через dependency injection FastAPI через `Depends(get_session)`, що забезпечує автоматичне створення та закриття сесій для кожного запиту. Додатково, для складних операцій використовується контекстний менеджер `session_scope()`, який забезпечує commit при успішному завершенні, rollback при помилках та закриття сесії в блоці `finally`. Це дозволяє використовувати сесії вручну для операцій, які не є частиною HTTP-запиту.

**Як забезпечується цілісність даних при помилках** — цілісність даних забезпечується через транзакції SQLite, які гарантують атомарність операцій (всі зміни виконуються разом або не виконуються взагалі). При помилках виконується rollback, що скасовує всі зміни в транзакції. Foreign keys забезпечують референційну цілісність — не можна створити запис з неіснуючим `user_id`. Унікальні індекси (наприклад, на `email` в таблиці `user`, на `(user_id, blocked_user_id)` в таблиці `userblock`) запобігають дублюванню даних. Обмеження NOT NULL забезпечують, що обов'язкові поля завжди заповнені.

## Продуктивність та масштабованість

Продуктивність та масштабованість БД залежать від індексів, обсягу даних та можливостей SQLite.

**Індекси на ключових полях** — база даних має індекси на всіх важливих полях для швидкого пошуку:
- `id` — первинний ключ (автоматично індексований)
- `email` в таблиці `user` — унікальний індекс для швидкого пошуку користувача за email
- `user_id` в таблицях `predictionhistory`, `assistantmessage`, `passwordresettoken`, `userblock` — індекси для швидкого пошуку записів користувача
- `token` в таблиці `passwordresettoken` — унікальний індекс для швидкого пошуку токену
- `uuid` в таблиці `chat` — унікальний індекс для швидкого пошуку чату за UUID
- `chat_id` в таблиці `chatmessage` — індекс для швидкого пошуку повідомлень чату
- `sender_id` в таблиці `chatmessage` — індекс для швидкого пошуку повідомлень відправника
- `user1_id`, `user2_id` в таблиці `chat` — індекси для швидкого пошуку чатів користувача
- `user_id`, `blocked_user_id` в таблиці `userblock` — індекси для швидкого пошуку блокувань
- Унікальний складений індекс на `(user_id, blocked_user_id)` в таблиці `userblock` для запобігання дублюванню

**Які таблиці ростуть найшвидше** — таблиця `predictionhistory` росте найшвидше, оскільки кожен прогноз створює новий запис, а користувачі можуть виконувати багато прогнозів. Таблиця `chatmessage` також швидко росте при активному використанні чатів. Таблиця `assistantmessage` росте при активному використанні AI-асистента. Таблиця `user` росте повільно, оскільки нові користувачі реєструються рідко. Таблиці `chat`, `userblock`, `passwordresettoken` ростуть помірно.

**Що буде важливим для масштабування** — для масштабування системи важливо:
- **Перехід з SQLite на PostgreSQL** — SQLite має обмеження для високих навантажень (один writer, обмежена конкурентність, файлова система). PostgreSQL забезпечить кращу продуктивність, масштабованість, реплікацію та резервне копіювання
- **Індексація** — додавання індексів на поля, які часто використовуються в WHERE, ORDER BY, JOIN (наприклад, `created_at` для сортування, `target` для фільтрації прогнозів)
- **Шардінг** — теоретично можна розділити дані по таблицях або базах для різних користувачів, але це складне рішення, яке потребує змін архітектури
- **Архівування старих записів** — перенесення старих прогнозів, повідомлень та інших даних в окрему таблицю або базу для зменшення розміру активної БД та покращення продуктивності запитів
- **Кешування** — використання Redis або іншого кешу для часто запитуваних даних (наприклад, профілі користувачів, статистика)
- **Пагінація** — обмеження кількості записів, що повертаються в одному запиті, для зменшення навантаження на БД та покращення продуктивності

## Як різні модулі системи використовують базу даних

Різні модулі системи використовують базу даних для різних цілей через репозиторійний шар.

**Модуль аутентифікації** використовує БД для:
- **Створення користувача** — через `create_user()` у `repositories.py`, яка створює новий запис `User` з email, хешем пароля, display_name та іншими полями, зберігає його в БД через `session.add()` та `session.commit()`, повертає створеного користувача з згенерованим `id`
- **Пошук користувача за email** — через `get_user_by_email()` у `repositories.py`, яка виконує SQL-запит `select(User).where(User.email == email)` для знаходження користувача за email, використовується при вході та перевірці унікальності email при реєстрації
- **Перевірка пароля** — пароль не зберігається в БД, але хеш пароля зберігається в полі `hashed_password`, перевірка виконується через `verify_password()` у `auth_utils.py`, яка порівнює введений пароль з хешем через bcrypt

**Модуль прогнозів** використовує БД для:
- **Запис результатів** — через `add_prediction_history()` (або `save_history_entry()`) у `repositories.py`, яка створює новий запис `PredictionHistory` з `user_id`, `target`, `model_name`, `probability`, `risk_bucket`, `inputs` (JSON з вхідними даними та топ факторами), зберігає його в БД, використовується після успішного прогнозування для збереження історії
- **Читання історії для відображення** — через `get_all_prediction_history()` (або `list_prediction_history()`) у `repositories.py`, яка виконує SQL-запит `select(PredictionHistory).where(PredictionHistory.user_id == user_id).order_by(PredictionHistory.created_at.desc())` для отримання всіх прогнозів користувача, відсортованих за датою (найновіші спочатку), використовується ендпоінтом `/users/history` для відображення історії на фронтенді

**Модуль чатів** використовує БД для:
- **Створення чатів** — через `get_or_create_chat()` у `repositories.py`, яка перевіряє наявність існуючого чату між двома користувачами, створює новий чат, якщо не знайдено, зберігає його в БД, використовується ендпоінтом `POST /api/chats` для створення або отримання чату
- **Додавання повідомлень** — через `add_chat_message()` у `repositories.py`, яка створює новий запис `ChatMessage` з `chat_id`, `sender_id`, `content`, зберігає його в БД, оновлює `updated_at` чату через `chat.touch()`, використовується ендпоінтом `POST /api/chats/{chat_uuid}/messages` для відправки повідомлень
- **Вибірка історії** — через `get_chat_messages()` у `repositories.py`, яка виконує SQL-запит `select(ChatMessage).where(ChatMessage.chat_id == chat_id).order_by(ChatMessage.created_at.asc())` для отримання всіх повідомлень чату, відсортованих за часом, використовується ендпоінтом `GET /api/chats/{chat_uuid}` для відображення історії чату

**Модуль API-status** використовує БД для:
- **Тестування з'єднання з БД** — ендпоінт `/system/database/stats` виконує SQL-запити для підрахунку записів у таблицях, обчислення розміру БД, отримання активності, що дозволяє перевірити доступність БД та отримати статистику
- **Відображення статусу** — результати запитів повертаються як JSON з полями `users_count`, `predictions_count`, `chats_count`, `messages_count`, `assistant_messages_count`, `database_size_bytes`, `last_activity`, використовуються на сторінці `/api-status` для відображення стану БД

**Модуль блокувань** використовує БД для:
- **Додавання/видалення блоків** — через `block_user()` та `unblock_user()` у `repositories.py`, які створюють або видаляють записи в таблиці `userblock`, перевіряють наявність існуючого блокування перед створенням, використовуються ендпоінтами `/users/block` та `/users/unblock`
- **Фільтрація списків користувачів** — через `is_user_blocked()` та `get_blocked_user_ids()` у `repositories.py`, які перевіряють наявність блокування між користувачами, використовуються при створенні чатів, відправці повідомлень, отриманні списку користувачів для фільтрації заблокованих

**Модуль AI-асистента** використовує БД для:
- **Збереження повідомлень** — через `add_message()` у `repositories.py`, яка створює новий запис `AssistantMessage` з `user_id`, `role` (user або assistant), `content`, опційним `prediction_id` для контексту, зберігає його в БД, використовується ендпоінтом `POST /assistant/chat` для збереження історії діалогу
- **Отримання історії** — через `get_user_messages()` у `repositories.py`, яка виконує SQL-запит `select(AssistantMessage).where(AssistantMessage.user_id == user_id).order_by(AssistantMessage.created_at.asc())` для отримання повідомлень користувача, використовується ендпоінтом `GET /assistant/history` для відображення історії чату

## Безпека даних

Безпека даних забезпечується через хешування паролів, відсутність зберігання чутливих даних у відкритому вигляді та обмеження доступу через автентифікацію.

**Як зберігаються паролі** — паролі зберігаються тільки через хеш через bcrypt у полі `hashed_password`. Хешування виконується через `get_password_hash()` у `auth_utils.py`, яка генерує salt та хешує пароль через bcrypt. Хеш унікальний для кожного пароля навіть при однакових значеннях завдяки автоматичній генерації salt. Bcrypt має обмеження 72 байти для пароля, тому паролі обмежуються до 72 байтів перед хешуванням.

**Відсутність зберігання "чистих" паролів** — оригінальні паролі ніколи не зберігаються в БД. Паролі хешуються перед збереженням, а при перевірці використовується `verify_password()`, яка порівнює введений пароль з хешем через bcrypt. Це означає, що навіть при компрометації БД зловмисники не зможуть отримати оригінальні паролі, оскільки вони не зберігаються.

**Можлива анонімізація чутливих медичних даних** — наразі медичні дані (вік, стать, ІМТ, тиск, глюкоза, холестерин) зберігаються в таблиці `predictionhistory` у полі `inputs` як JSON. Дані пов'язані з користувачем через `user_id`, що дозволяє ідентифікувати особисті дані. В майбутньому можна додати анонімізацію через видалення або заміну `user_id` на анонімний ідентифікатор для старих записів, шифрування чутливих полів або використання окремої таблиці для анонімізованих даних для аналітики.

**Обмеження доступу через auth-рівень** — доступ до даних обмежується через автентифікацію у ендпоінтах через `Depends(require_current_user)`. Користувачі можуть отримувати доступ тільки до своїх даних (свої прогнози, свої чати, свої повідомлення). Перевірка виконується через `user_id` у SQL-запитах (наприклад, `where(PredictionHistory.user_id == current_user.id)`), що запобігає доступу до чужих даних навіть при спробі маніпуляції запитами.

## Можливі напрямки покращення схеми БД

Схема БД може бути покращена для підвищення продуктивності, масштабованості та функціональності.

**Перехід на більш потужну СУБД** — перехід з SQLite на PostgreSQL забезпечить кращу продуктивність при високих навантаженнях, підтримку одночасних writer-ів, кращу конкурентність, реплікацію для резервного копіювання та масштабування, підтримку складних запитів, тригери, процедури, кращу підтримку JSON для полів `inputs` в таблиці `predictionhistory`, підтримку full-text search для пошуку в повідомленнях.

**Виділення логів у окрему таблицю/схему** — створення окремої таблиці для логування важливих подій (вхід, вихід, зміна профілю, помилки) з полями `id`, `user_id`, `event_type`, `event_data` (JSON), `created_at`. Це дозволить відстежувати активність користувачів, діагностувати помилки, проводити аудит доступу до даних та аналізувати поведінку користувачів без впливу на основні таблиці.

**Додавання audit log** — створення таблиці `audit_log` для відстеження змін профілю, даних, налаштувань з полями `id`, `user_id`, `table_name`, `record_id`, `action` (create, update, delete), `old_values` (JSON), `new_values` (JSON), `created_at`, `ip_address`, `user_agent`. Це дозволить відстежувати хто, коли та що змінив, відновлювати дані при помилках, проводити аудит безпеки та дотримуватися вимог GDPR для логування доступу до персональних даних.

**Оптимізація індексів** — додавання індексів на поля, які часто використовуються в WHERE, ORDER BY, JOIN:
- Складений індекс на `(user_id, created_at)` в таблиці `predictionhistory` для швидкого отримання історії користувача, відсортованої за датою
- Складений індекс на `(chat_id, created_at)` в таблиці `chatmessage` для швидкого отримання повідомлень чату, відсортованих за часом
- Складений індекс на `(user_id, created_at)` в таблиці `assistantmessage` для швидкого отримання історії асистента
- Індекс на `created_at` в таблицях для швидкого сортування за датою
- Індекс на `target` в таблиці `predictionhistory` для фільтрації за типом прогнозу
- Індекс на `is_active` в таблиці `user` для фільтрації активних користувачів

**Розділення data warehouse та онлайн-схеми (OLAP vs OLTP)** — розділення операційної БД (OLTP) для щоденних операцій (створення користувачів, збереження прогнозів, відправка повідомлень) та аналітичної БД (OLAP) для аналітики (статистика, тренди, звіти). Аналітична БД може містити агреговані дані, індекси для швидких запитів, архівовані дані для історичного аналізу. Це дозволить не навантажувати операційну БД складними аналітичними запитами та покращити продуктивність обох систем.

**Додавання soft delete** — додавання поля `deleted_at` (datetime, опційний) до таблиць для "м'якого" видалення записів замість фізичного видалення. Це дозволить відновлювати видалені дані, зберігати історію змін, дотримуватися вимог GDPR для збереження даних, фільтрувати видалені записи в запитах через `where(deleted_at.is_(None))`.

**Додавання версіонування даних** — створення таблиць версій для відстеження змін даних (наприклад, `user_version` для змін профілю, `prediction_version` для змін прогнозів). Це дозволить відстежувати історію змін, відновлювати попередні версії, проводити аудит змін та аналізувати тренди змін даних у часі.

