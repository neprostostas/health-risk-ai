# API проєкту HealthRisk.AI

API (Application Programming Interface) проєкту HealthRisk.AI є центральним шаром взаємодії між фронтендом, ML-моделями, базою даних та системою прогнозування ризиків здоров'я. Бекенд побудований на FastAPI — сучасному асинхронному веб-фреймворку для Python, який забезпечує високу продуктивність, автоматичну генерацію OpenAPI-документації та вбудовану валідацію даних через Pydantic. FastAPI обрано для цього проєкту через його зручність у роботі з ML-моделями, інтеграцію з асинхронними операціями та можливість швидкої розробки REST API.

## Архітектура API

Архітектура API організована за модульним принципом з чітким розділенням відповідальності між компонентами.

**Головний файл FastAPI** (`src/service/api.py`) містить створення додатку, конфігурацію middleware, монтування статичних файлів та реєстрацію роутерів. Тут визначені HTML-роути для SPA (Single Page Application), які завжди повертають HTML-сторінку фронтенду, та системні ендпоінти для перевірки здоров'я сервісу.

**Модулі ендпоінтів** (`src/service/routers/`) містять логіку окремих груп функціональності:
- `routers/assistant.py` — ендпоінти для AI-асистента здоров'я та інтеграції з Ollama
- `routers/chats.py` — ендпоінти для системи чатів між користувачами

**Логіка аутентифікації** (`src/service/auth_utils.py`, `src/service/routes_auth.py`) включає функції для створення та валідації JWT-токенів, хешування паролів, перевірки авторизації користувачів та реалізацію всіх ендпоінтів автентифікації (реєстрація, вхід, відновлення пароля, оновлення профілю).

**Робота з базою даних** (`src/service/db.py`, `src/service/repositories.py`) організована через SQLModel ORM. Модуль `db.py` містить налаштування підключення до SQLite, ініціалізацію таблиць та функції для отримання сесій БД. Модуль `repositories.py` інкапсулює всі CRUD-операції для роботи з користувачами, історією прогнозів, чатами, повідомленнями та блокуваннями користувачів.

**Pydantic-схеми** (`src/service/schemas.py`) визначають структуру вхідних та вихідних даних для всіх ендпоінтів. Вони забезпечують автоматичну валідацію типів, діапазонів значень та обов'язкових полів на рівні API, що гарантує коректність даних перед обробкою.

**ML та інференс** (`src/service/model_registry.py`, `src/service/api.py`) реалізовані через реєстр моделей, який завантажує та кешує навчені моделі з файлової системи. Моделі зберігаються у форматі `.joblib` у директорії `artifacts/models/` та завантажуються в пам'ять при першому використанні. Реєстр підтримує завантаження чемпіонських моделей (автоматично обраних найкращих) та конкретних моделей за ключем, з пріоритетом каліброваних версій.

**Інтеграція з Ollama** (`src/service/services/assistant_llm.py`) виконується через HTTP-запити до локального Ollama API. Модуль формує контекст про стан здоров'я користувача на основі останніх прогнозів, конструює промпти для LLM та викликає Ollama для генерації відповідей.

**API-status сторінка** обслуговується через HTML-роут `/api-status` у головному файлі API, який повертає SPA-сторінку для моніторингу стану системи. Статус перевіряється через окремі ендпоінти `/health`, `/system/database/stats` та `/assistant/health`.

**Health-check ендпоінти** розташовані у головному файлі API та включають `/health` для перевірки стану сервісу та `/system/database/stats` для отримання статистики бази даних.

**Робота з фронтендом SPA** організована через комбінацію HTML-роутів (які завжди повертають HTML) та JSON API ендпоінтів (які обробляють дані). Middleware нормалізує URL-шляхи, обробляє CORS та перевіряє автентифікацію для захищених роутів.

## Основні групи ендпоінтів

API проєкту організовано за функціональними групами ендпоінтів, кожна з яких виконує конкретні завдання.

**`/predict`** — основний ендпоінт для прогнозування ризиків здоров'я. Приймає параметри пацієнта (вік, стать, ІМТ, артеріальний тиск, глюкоза, холестерин) та цільову змінну (діабет або ожиріння), завантажує відповідну ML-модель, виконує інференс та повертає ймовірність ризику, категорію ризику (низький, помірний, високий), топ фактори впливу та метадані моделі. Якщо користувач автентифікований, прогноз автоматично зберігається в історії.

**`/explain`** — ендпоінт для пояснення моделі через permutation importance. Завантажує чемпіонську модель, використовує вибірку з датасету для обчислення важливості ознак та повертає ранжований список факторів, що найбільше впливають на прогноз.

**`/metadata`** — повертає метадані API, включаючи список доступних цільових змінних, схему ознак для валідації вхідних даних та версії моделей для кожного target.

**`/health-risk/latest`** — повертає останній збережений прогноз ризику для автентифікованого користувача. Використовується фронтендом для відображення поточного стану здоров'я користувача.

**`/auth/*`** — група ендпоінтів для аутентифікації та управління користувачами:
- `/auth/register` — реєстрація нового користувача з валідацією email, пароля та обов'язкових полів профілю
- `/auth/login` — вхід користувача з поверненням JWT-токена та профілю
- `/auth/me` — отримання профілю поточного автентифікованого користувача
- `/auth/update-profile` — оновлення профілю користувача (ім'я, прізвище, дата народження, стать, аватар)
- `/auth/change-password` — зміна пароля з перевіркою поточного пароля
- `/auth/forgot-password` — ініціалізація процесу відновлення пароля через email-токен
- `/auth/reset-password` — встановлення нового пароля через токен відновлення

**`/users/*`** — ендпоінти для управління користувачами:
- `/users/history` — отримання історії прогнозів користувача з можливістю фільтрації та пагінації
- `/users/history/stats` — статистика історії прогнозів для побудови діаграм (розподіл по цілям, категоріям ризику, моделям, часова серія)
- `/users/history/{id}` — видалення конкретного прогнозу з історії
- `/users/history/clear` — очищення всієї історії прогнозів користувача
- `/users/avatar` — завантаження аватару користувача з валідацією формату та розміру

**`/assistant/*`** — ендпоінти для AI-асистента здоров'я:
- `/assistant/chat` — відправка повідомлення асистенту з генерацією відповіді через Ollama
- `/assistant/history` — отримання історії повідомлень з асистентом
- `/assistant/health` — перевірка статусу Ollama сервера з вимірюванням латентності
- `/assistant/history` (DELETE) — видалення всієї історії повідомлень з асистентом

**`/api/chats/*`** — ендпоінти для системи чатів між користувачами:
- `/api/chats` — отримання списку всіх чатів користувача з інформацією про останнє повідомлення та кількість непрочитаних
- `/api/chats/{chat_uuid}` — отримання детальної інформації про конкретний чат з усіма повідомленнями
- `/api/chats` (POST) — створення нового чату або отримання існуючого між двома користувачами
- `/api/chats/{chat_uuid}/messages` (POST) — відправка повідомлення в чат
- `/api/chats/{chat_uuid}/read` (POST) — позначення всіх повідомлень у чаті як прочитаних
- `/api/chats/{chat_uuid}` (DELETE) — видалення чату та всіх його повідомлень
- `/api/chats/{chat_uuid}/pin` (PATCH) — закріплення або відкріплення чату
- `/api/chats/reorder` (PATCH) — зміна порядку чатів у списку
- `/api/chats/users` — отримання списку всіх активних користувачів для створення чатів
- `/api/chats/unread-count` — отримання загальної кількості непрочитаних повідомлень

**`/health`** — системний ендпоінт для перевірки стану API, повертає список доступних маршрутів та версію сервісу.

**`/system/database/stats`** — ендпоінт для отримання статистики бази даних, включаючи кількість записів у кожній таблиці, розмір БД та активність за останні 7 днів.

**HTML-роути** — всі маршрути для SPA (`/`, `/app`, `/login`, `/register`, `/profile`, `/history`, `/api-status`, `/diagrams`, `/assistant`, `/chats`, `/reports`, `/forgot-password`, `/reset-password`, `/about`) завжди повертають HTML-сторінку фронтенду, яка обробляє роутинг клієнтською стороною.

## Як API працює з ML-моделями

API інтегрується з ML-моделями через систему реєстрації моделей, яка забезпечує їх завантаження, кешування та використання для інференсу.

**Зберігання моделей** відбувається у файловій системі у директорії `artifacts/models/`, організованій за цільовими змінними (`diabetes_present`, `obesity_present`). Кожна модель зберігається у форматі `.joblib` (бібліотека joblib для серіалізації Python-об'єктів), що включає повний pipeline: препроцесор (імпутація, стандартизація, one-hot encoding) та навчену модель. Калібровані версії моделей зберігаються окремо як `champion_calibrated.joblib`. Метадані моделей (назва, версія, метрики) зберігаються у файлі `champion.json`.

**Завантаження моделей** виконується через функції `load_champion()` та `load_model()` у модулі `model_registry.py`. При першому запиті модель завантажується з диску у пам'ять за допомогою `joblib.load()`, після чого кешується у словнику `_MODEL_CACHE` для швидкого доступу при наступних запитах. Система віддає перевагу каліброваним моделям, якщо вони доступні, інакше використовує звичайну чемпіонську модель.

**Pipeline використовується** для обробки вхідних даних перед інференсом. Pipeline складається з двох кроків: `preprocessor` (ColumnTransformer з SimpleImputer, StandardScaler та OneHotEncoder) та `model` (навчена модель класифікації). При отриманні запиту на прогноз API створює pandas DataFrame з одного рядка, передає його через pipeline, який автоматично виконує імпутацію пропущених значень, стандартизацію числових ознак та кодування категоріальних, після чого модель обчислює ймовірність позитивного класу.

**Передача даних до моделі** відбувається через конвертацію вхідних параметрів запиту (Pydantic-модель `PredictRequest`) у DataFrame з колонками, що відповідають ознакам моделі. API використовує схему ознак (`get_feature_schema()`) для визначення необхідних полів та їх типів. Пропущені значення заповнюються як `None` і обробляються препроцесором pipeline.

**Повернення оцінки ризику** виконується у форматі `PredictResponse`, який включає цільову змінну, ймовірність (від 0 до 1), категорію ризику (low, medium, high), назву та версію моделі, інформацію про калібрування, топ фактори впливу та примітку про методику розрахунку. Ймовірність обмежується діапазоном (0.0001, 0.9999) для захисту від екстремальних значень та стабільності категорій ризику.

**Визначення factor impact** (важливих факторів) виконується через функцію `calculate_top_factors_simple()`, яка аналізує нормалізовані значення ознак та їх вплив на прогноз. Фактори ранжуються за абсолютним значенням впливу та повертаються як топ-5 найважливіших. Для детального пояснення моделі використовується ендпоінт `/explain`, який обчислює permutation importance на вибірці з датасету.

**Формування JSON-відповідей** відбувається автоматично через Pydantic-схеми, які серіалізують дані у JSON-формат. Всі відповіді містять структуровані дані з типізованими полями, що забезпечує узгодженість та валідацію на рівні API.

**Обробка обох моделей** (діабет та ожиріння) виконується через параметр `target` у запиті, який визначає, яку модель завантажити. API підтримує обидві цільові змінні через єдиний інтерфейс, що дозволяє фронтенду використовувати однакову логіку для роботи з різними типами ризиків.

## Як API працює з базою даних

API використовує SQLite як основну базу даних, яка зберігається у файлі `data/app.db`. Взаємодія з БД організована через SQLModel ORM, який поєднує можливості Pydantic для валідації та SQLAlchemy для роботи з базою даних.

**Дані, що зберігаються** включають:
- **Користувачі** (`user`) — email, хеш пароля, профіль (ім'я, прізвище, дата народження, стать), аватар, статус активності, timestamps створення та оновлення
- **Історія прогнозів** (`predictionhistory`) — зв'язок з користувачем, цільова змінна, назва моделі, ймовірність, категорія ризику, вхідні параметри (у форматі JSON), timestamp створення
- **Повідомлення асистента** (`assistantmessage`) — зв'язок з користувачем, роль (user/assistant), вміст повідомлення, опційний зв'язок з прогнозом, timestamp створення
- **Чати** (`chat`) — UUID чату, два користувачі-учасники, статус закріплення, порядок у списку, timestamps
- **Повідомлення в чатах** (`chatmessage`) — зв'язок з чатом, відправник, вміст, статус прочитання, timestamps
- **Токени відновлення пароля** (`passwordresettoken`) — токен, зв'язок з користувачем, час закінчення дії
- **Блокування користувачів** (`userblock`) — зв'язок між двома користувачами, timestamp блокування

**Читання та запис інформації** виконується через функції у модулі `repositories.py`, які інкапсулюють SQL-запити та роботу з сесіями БД. API отримує сесію БД через dependency injection (`Depends(get_session)`), що забезпечує автоматичне управління транзакціями та закриття з'єднань.

**ORM / SQLite** використовується через SQLModel, який дозволяє визначати моделі даних як Python-класи з автоматичним мапінгом на таблиці БД. SQLite обрано через простоту розгортання (файлова БД), відсутність необхідності в окремому сервері та достатню продуктивність для середнього навантаження. Міграції виконуються програмно через функцію `migrate_add_missing_columns()` при старті додатку.

**Формування історії прогнозів** відбувається автоматично при успішному прогнозуванні, якщо користувач автентифікований. API зберігає всі вхідні параметри, результат прогнозу, топ фактори та метадані моделі у форматі JSON у полі `inputs` таблиці `predictionhistory`. Історія доступна через ендпоінт `/users/history` з можливістю пагінації та фільтрації.

**Формат зберігання** використовує JSON для складних структур даних (вхідні параметри прогнозу, топ фактори), що дозволяє гнучко зберігати різноманітні дані без зміни схеми БД. Timestamps зберігаються у форматі UTC та автоматично генеруються при створенні записів.

**Робота з timestamps** виконується через поля `created_at` та `updated_at` у базових моделях, які автоматично оновлюються при створенні та модифікації записів. API використовує UTC для всіх часових міток для узгодженості між часовими поясами.

**Статуси для API-status** обчислюються через ендпоінт `/system/database/stats`, який підраховує кількість записів у кожній таблиці, розмір файлу БД та активність за останні 7 днів. Ці дані використовуються фронтендом для відображення статистики системи на сторінці `/api-status`.

## Аутентифікація

Система аутентифікації API побудована на JWT (JSON Web Tokens) та забезпечує безпечний доступ до захищених ресурсів.

**JWT токени** використовуються для автентифікації користувачів. Після успішного входу або реєстрації користувач отримує access token, який містить email користувача та час закінчення дії (за замовчуванням 60 хвилин). Токени підписуються секретним ключем через алгоритм HS256. Refresh токени не використовуються — користувач повинен повторно увійти після закінчення терміну дії токена.

**Структура middleware** включає `OAuth2PasswordBearer`, який автоматично витягує токен з заголовка `Authorization` у форматі `Bearer <token>`. Middleware перевіряє валідність токена, розшифровує його та отримує email користувача, після чого завантажує користувача з БД та передає його у залежності (`Depends(get_current_user)` або `Depends(require_current_user)`).

**Перевірка токена** виконується через функцію `get_current_user()`, яка декодує JWT, перевіряє його валідність, завантажує користувача з БД та перевіряє, чи не заблокований користувач. Якщо токен невалідний або користувач не знайдений, функція повертає `None` (для опційної автентифікації) або викидає HTTPException (для обов'язкової автентифікації через `require_current_user()`).

**Захищені та незахищені роутери** розрізняються через dependency injection. Ендпоінти, які вимагають автентифікації, використовують `Depends(require_current_user)`, що гарантує наявність автентифікованого користувача. Публічні ендпоінти (наприклад, `/health`, `/metadata`, `/assistant/health`) не вимагають автентифікації. Деякі ендпоінти (наприклад, `/predict`) підтримують опційну автентифікацію через `Depends(get_current_user)`, що дозволяє використовувати їх без входу, але зберігати історію тільки для автентифікованих користувачів.

**Роль LocalStorage на фронтенді** полягає у зберіганні JWT-токена після успішного входу. Токен зберігається під ключем `hr_auth_token` та автоматично додається до всіх API-запитів у заголовку `Authorization`. Фронтенд перевіряє наявність токена при завантаженні сторінки та автоматично перенаправляє на сторінку входу, якщо токен відсутній або невалідний.

**Поведінка при перезавантаженні сторінки** включає автоматичну перевірку токена з LocalStorage та завантаження профілю користувача через ендпоінт `/auth/me`. Якщо токен валідний, користувач залишається автентифікованим; якщо ні — перенаправляється на сторінку входу. Фронтенд зберігає стан автентифікації у пам'яті та синхронізує його з LocalStorage.

## Генерація PDF/Excel/CSV/JSON на бекенді та фронтенді

Генерація звітів у проєкті реалізована переважно на фронтенді, а API забезпечує передачу необхідних даних у форматі JSON.

**Генерація PDF відбувається на фронтенді** через бібліотеку jsPDF. API не генерує PDF безпосередньо, а надає дані через ендпоінти `/users/history`, `/users/history/stats` та `/predict`, які повертають структуровані JSON-дані. Фронтенд завантажує ці дані, рендерить графіки через Chart.js, конвертує їх у зображення та вставляє у PDF-документ разом з текстом, таблицями та форматуванням. PDF включає інформацію про прогноз, фактори ризику, графіки розподілів та рекомендації.

**Передача сирих даних у форматі JSON** виконується через стандартні API ендпоінти. Всі відповіді API повертаються у форматі JSON з структурованими даними, що дозволяє фронтенду легко обробляти їх для генерації звітів. API не виконує серверного рендерингу — вся логіка форматування та візуалізації знаходиться на клієнті.

**Формування структури для звітів** відбувається на фронтенді на основі даних з API. Фронтенд комбінує дані з різних ендпоінтів (прогнози, історія, статистика) та формує єдину структуру для звіту. API забезпечує консистентність даних через Pydantic-схеми, але не визначає формат звіту.

**Рендеринг PDF із діаграм** виконується через експорт графіків Chart.js у зображення (canvas to image), які потім вставляються у PDF. Фронтенд використовує jsPDF для створення документа, додавання тексту, таблиць, зображень графіків та форматування. PDF підтримує кирилицю через завантаження спеціальних шрифтів (DejaVu Sans).

**Взаємодія API ↔ фронт** організована через REST API з JSON-відповідями. Фронтенд робить HTTP-запити через `fetch()`, отримує структуровані дані та використовує їх для генерації звітів. API не знає про формат звітів — він лише надає дані, а фронтенд визначає, як їх відобразити.

**Генерація Excel/CSV** також виконується на фронтенді через бібліотеку `xlsx-js-style`. API надає дані у JSON, а фронтенд конвертує їх у формат Excel або CSV для експорту. API не має спеціальних ендпоінтів для експорту — всі дані доступні через стандартні JSON API.

## Інтеграція API з AI-моделлю Ollama

API інтегрується з локальним Ollama сервером для реалізації AI-асистента здоров'я, який надає персоналізовані рекомендації користувачам.

**Виклик локального Ollama** виконується через HTTP POST-запити до `http://localhost:11434/api/generate` з використанням бібліотеки `requests`. API не підтримує streaming — всі запити виконуються синхронно з отриманням повної відповіді. Модель за замовчуванням — `llama3`, яка повинна бути завантажена локально через команду `ollama pull llama3`.

**Ендпоінти для Ollama** включають `/assistant/chat` для відправки повідомлень асистенту та `/assistant/health` для перевірки статусу Ollama сервера. Ендпоінт `/assistant/chat` приймає повідомлення користувача, формує контекст про стан здоров'я на основі останніх прогнозів, конструює промпт для LLM, викликає Ollama та повертає відповідь асистента. Ендпоінт `/assistant/health` виконує тестовий запит до Ollama, вимірює латентність та повертає статус доступності.

**Валідація** включає перевірку наявності повідомлення користувача, валідність `prediction_id` (якщо вказано) та належність прогнозу користувачу. API перевіряє, чи запущений Ollama сервер, та обробляє помилки підключення (timeout, connection error) з поверненням зрозумілих повідомлень користувачу.

**Визначення статусу Ollama** виконується через ендпоінт `/assistant/health`, який робить простий тестовий запит до Ollama та вимірює час відгуку. Статус може бути "online" (Ollama працює), "offline" (недоступна), "timeout" (перевищення часу очікування) або "error" (інша помилка). API повертає латентність у мілісекундах та timestamp перевірки.

**Робота `/assistant/chat`** включає збереження повідомлення користувача в БД, формування контексту про стан здоров'я (останній прогноз, ймовірність, категорія ризику, ключові фактори), конструювання системного промпту з інструкціями для асистента (не ставити діагнози, не призначати лікування), виклик Ollama з повним промптом, збереження відповіді асистента в БД та повернення відповіді користувачу. Контекст формується українською або англійською мовою залежно від параметра `language` у запиті.

## API-Status система

API-Status система забезпечує моніторинг стану всіх компонентів проєкту через веб-інтерфейс та JSON API.

**Сторінка `/api-status`** відображає стан API, бази даних та Ollama сервера. Сторінка є SPA-сторінкою, яка завантажується через HTML-роут та використовує JavaScript для періодичного оновлення статусів через API ендпоінти. Інтерфейс включає індикатори стану (онлайн/офлайн), графіки часу відгуку, статистику активності та детальну інформацію про кожен компонент.

**Перевірка роботи БД** виконується через ендпоінт `/system/database/stats`, який підраховує кількість записів у всіх таблицях, розмір файлу БД та активність за останні 7 днів. API виконує SQL-запити для отримання статистики та повертає структуровані дані у JSON. Статус БД вважається "ok", якщо запити виконуються успішно, та "error", якщо виникає помилка.

**Перевірка роботи Ollama** виконується через ендпоінт `/assistant/health`, який робить тестовий HTTP-запит до Ollama API та вимірює латентність. Статус може бути "online" (Ollama працює та відповідає), "offline" (недоступна через помилку підключення), "timeout" (перевищення часу очікування) або "error" (інша помилка). API повертає детальну інформацію про помилку, якщо вона виникла.

**Перевірка роботи ML моделей** виконується через спробу завантаження чемпіонських моделей при старті API або через ендпоінт `/metadata`, який повертає інформацію про доступні моделі та їх версії. Якщо моделі не знайдено, API повертає помилку 404. Статус моделей відображається на сторінці `/api-status` через інформацію з `/metadata`.

**Перевірка власних ендпоінтів** виконується через ендпоінт `/health`, який повертає список доступних маршрутів, версію API та загальний статус сервісу. Фронтенд може використовувати цей ендпоінт для перевірки доступності API та отримання інформації про доступні endpoints.

**Логіка UI-анімацій** реалізована на фронтенді через JavaScript, який періодично (кожні 10 секунд) робить запити до API ендпоінтів статусу та оновлює індикатори на сторінці. Фронтенд зберігає історію статусів для побудови графіків часу відгуку та відображення трендів. Анімації включають індикатори завантаження, плавні переходи між станами та візуалізацію графіків через Chart.js.

**Повернення статусів у JSON** виконується через стандартні API ендпоінти, які повертають структуровані дані з полями `status`, `is_available`, `latency_ms`, `timestamp` та опційними полями `error` для деталізації помилок. Фронтенд парсить ці відповіді та відображає їх у зручному для користувача форматі.

## Формат відповідей API

Всі відповіді API повертаються у форматі JSON з чітко визначеною структурою, що забезпечує узгодженість та легкість обробки на фронтенді.

**JSON-структура для прогнозів** (`PredictResponse`) включає поля `target` (цільова змінна), `probability` (ймовірність від 0 до 1), `risk_bucket` (категорія ризику: low, medium, high), `model_name` (назва моделі), `version` (версія моделі), `is_calibrated` (чи використовується калібрована модель), `top_factors` (список факторів з полями `feature` та `impact`), `note` (примітка про методику розрахунку). Структура гарантує, що всі необхідні дані для відображення прогнозу присутні у відповіді.

**JSON-структура для діаграм** формується через ендпоінт `/users/history/stats`, який повертає `PredictionHistoryStats` з полями `total_predictions` (загальна кількість прогнозів), `by_target` (розподіл по цільових змінних), `by_risk_bucket` (розподіл по категоріях ризику), `by_model` (розподіл по моделям), `by_target_and_risk` (комбінований розподіл), `time_series` (часова серія з датами та ймовірностями). Ці дані використовуються фронтендом для побудови графіків через Chart.js.

**JSON-структура для історії** (`PredictionHistoryResponse`) включає поле `items` зі списком `PredictionHistoryItem`, кожен з яких містить `id`, `target`, `model_name`, `probability`, `risk_bucket`, `inputs` (вхідні параметри у форматі JSON), `created_at` (timestamp). Список сортується за часом створення (від новіших до старіших) та підтримує пагінацію через параметр `limit`.

**JSON-структура для API-status** включає відповіді з ендпоінтів `/health` (статус API, список маршрутів, версія), `/system/database/stats` (статистика БД, розмір файлу, активність за 7 днів), `/assistant/health` (статус Ollama, латентність, помилки). Всі відповіді містять поле `status` зі значенням "ok", "error" або специфічним статусом (наприклад, "online", "offline" для Ollama), поле `timestamp` з часом перевірки та опційні поля з деталями помилок.

**JSON-структура для чатів** включає `ChatListItem` (список чатів з полями `id`, `uuid`, `other_user`, `last_message`, `unread_count`, `updated_at`, `is_pinned`, `order`), `ChatDetailResponse` (детальна інформація про чат з повідомленнями), `ChatMessageItem` (повідомлення з полями `id`, `sender_id`, `content`, `created_at`, `read_at`). Структура забезпечує повну інформацію для відображення списку чатів, деталей конкретного чату та повідомлень.

## Взаємодія API та фронтенду

Взаємодія між API та фронтендом організована через REST API з JSON-відповідями та SPA-архітектуру на клієнті.

**SPA-архітектура** реалізована через чистий JavaScript без фреймворків. Фронтенд завантажується один раз через HTML-роут API, після чого весь роутинг виконується клієнтською стороною через бібліотеку Navigo. API завжди повертає одну HTML-сторінку для всіх маршрутів, а JavaScript визначає, який контент відобразити на основі URL.

**Спілкування API з фронтом** відбувається через HTTP-запити з використанням `fetch()`. Фронтенд робить запити до JSON API ендпоінтів, отримує структуровані дані та оновлює інтерфейс без перезавантаження сторінки. Всі запити включають JWT-токен у заголовку `Authorization` для автентифікованих користувачів.

**Використання fetch** включає обробку помилок, перевірку статусів відповідей та парсинг JSON. Фронтенд використовує async/await для асинхронних запитів та обробляє помилки через try/catch. При отриманні помилки 401 (неавторизований) фронтенд автоматично перенаправляє користувача на сторінку входу.

**Система route-sync** забезпечує синхронізацію між клієнтським роутингом та серверними HTML-роутами. API визначає список дозволених маршрутів (`ALLOWLISTED_ROUTES`), які не перенаправляються на сторінку входу, та перевіряє автентифікацію для захищених маршрутів. Фронтенд використовує цю інформацію для коректного відображення контенту.

**Обробка помилок API** виконується через стандартні HTTP статус-коди (400 — невалідний запит, 401 — неавторизований, 403 — заборонено, 404 — не знайдено, 422 — помилка валідації, 500 — внутрішня помилка сервера). API повертає детальні повідомлення про помилки у полі `detail` JSON-відповіді. Фронтенд обробляє ці помилки та відображає зрозумілі повідомлення користувачу.

**Робота у offline-mode** не підтримується явно — фронтенд не має service workers або кешування для роботи без інтернету. Однак, якщо API недоступний, фронтенд відображає повідомлення про помилку підключення та дозволяє користувачу спробувати ще раз. JWT-токени зберігаються у LocalStorage, тому користувач залишається автентифікованим навіть після перезавантаження сторінки.

## Безпека API

Безпека API забезпечується через аутентифікацію, авторизацію, валідацію даних та захист від основних вразливостей.

**Захищено аутентифікацією** всі ендпоінти, що вимагають доступу до персональних даних користувача: `/auth/me`, `/auth/update-profile`, `/auth/change-password`, `/users/history`, `/users/history/*`, `/assistant/chat`, `/assistant/history`, `/api/chats/*`. Ці ендпоінти використовують `Depends(require_current_user)` для гарантії наявності автентифікованого користувача.

**Не захищено аутентифікацією** публічні ендпоінти: `/health`, `/metadata`, `/assistant/health`, `/system/database/stats`, `/predict` (опційна автентифікація), `/explain`. Ці ендпоінти доступні без входу, але деякі обмежені за іншими критеріями (наприклад, `/predict` не зберігає історію для неавтентифікованих користувачів).

**Захист від витоку ML-моделі** забезпечується через те, що моделі зберігаються у файловій системі сервера та не експортуються через API. API не надає ендпоінтів для завантаження моделей — вони доступні тільки для інференсу через `/predict` та `/explain`. Метадані моделей (назва, версія, метрики) доступні через `/metadata`, але самі файли моделей недоступні.

**Обмеження доступів** включають перевірку належності ресурсів користувачу. Користувач може отримувати тільки свою історію прогнозів, свої чати та повідомлення. Спроби доступу до чужих ресурсів повертають помилку 403 (Forbidden). Блокування користувачів перевіряється при створенні чатів та відправці повідомлень — заблоковані користувачі не можуть взаємодіяти один з одним.

**Робота з блокуванням користувача** реалізована через таблицю `userblock`, яка зберігає зв'язки між користувачами, які заблокували один одного. API перевіряє блокування при створенні чатів, відправці повідомлень та відображенні списку користувачів. Заблоковані користувачі відображаються у списку з позначкою `is_blocked=True`, але не можуть створювати чати або відправляти повідомлення один одному.

## Обмеження та майбутня робота

API проєкту має певні обмеження та області для покращення у майбутньому.

**Що API робить:**
- Надає REST API для прогнозування ризиків здоров'я через ML-моделі
- Забезпечує аутентифікацію та авторизацію користувачів через JWT
- Зберігає історію прогнозів та надає доступ до неї
- Інтегрується з Ollama для AI-асистента здоров'я
- Надає систему чатів між користувачами
- Забезпечує моніторинг стану системи через API-status
- Підтримує обидві цільові змінні (діабет та ожиріння)
- Надає метадані про моделі та схему ознак

**Чого API не робить:**
- Не генерує PDF/Excel звіти (це робить фронтенд)
- Не підтримує streaming для Ollama (всі запити синхронні)
- Не має refresh токенів (користувач повинен повторно входити після закінчення терміну дії токена)
- Не підтримує багатомовність на рівні API (тільки українська та англійська для Ollama)
- Не має rate limiting (немає обмежень на кількість запитів)
- Не підтримує версіонування API (всі ендпоінти в одній версії)
- Не має автоматичних міграцій БД (міграції виконуються програмно при старті)

**Що може бути покращено у майбутньому:**
- Додати refresh токени для продовження сесії без повторного входу
- Реалізувати rate limiting для захисту від зловмисних запитів
- Додати версіонування API (наприклад, `/api/v1/predict`) для забезпечення сумісності
- Покращити обробку помилок з детальнішими повідомленнями та логуванням
- Додати підтримку streaming для Ollama для покращення UX при довгих відповідях
- Реалізувати автоматичні міграції БД через Alembic або аналогічний інструмент
- Додати кешування для часто використовуваних запитів (наприклад, метадані моделей)
- Покращити безпеку через додавання CORS-обмежень, CSRF-захисту та валідації вхідних даних
- Додати підтримку багатомовності на рівні API для всіх повідомлень про помилки
- Реалізувати webhooks для сповіщень про події (наприклад, нові прогнози, повідомлення)

**Потенційні розширення:**
- Додати підтримку нових цільових змінних (наприклад, серцево-судинні захворювання)
- Реалізувати batch-прогнозування для обробки кількох запитів одночасно
- Додати експорт даних у різних форматах (JSON, CSV, Excel) на рівні API
- Реалізувати систему нотифікацій для користувачів (email, push)
- Додати підтримку файлових завантажень для імпорту даних
- Реалізувати API для адміністраторів для управління користувачами та моделями
- Додати підтримку WebSocket для real-time оновлень (чати, нотифікації)
- Реалізувати систему аналітики для відстеження використання API

