# Зміст документації проєкту HealthRisk.AI

## 1. Вступ

### 1.1. Про проєкт
### 1.2. Мета та завдання
### 1.3. Структура документації

## 2. Архітектурний огляд системи (блок 10-ARCHITECTURE_OVERVIEW)

### 2.1. Високорівнева структура системи
### 2.2. Потік даних: від сирих NHANES до прогнозу ризику
### 2.3. Взаємодія користувача з системою
### 2.4. Логічні модулі та сторінки системи
### 2.5. Роль бази даних в архітектурі
### 2.6. Архітектура інтеграції з локальною AI-моделлю (Ollama)
### 2.7. Архітектура генерації звітів
### 2.8. Тестування як частина архітектури системи
### 2.9. Нефункціональні аспекти архітектури
### 2.10. Підсумок

## 3. Дані та підготовка датасету (блоки 0-DATA, 1-ETL)

### 3.1. Джерело даних: NHANES (National Health and Nutrition Examination Survey)
#### 3.1.1. Опис датасету NHANES
#### 3.1.2. Компоненти NHANES, що використовуються в проєкті
#### 3.1.3. Структура сирих даних

### 3.2. Цільовий датасет проєкту: health_dataset.csv
#### 3.2.1. Основні групи змінних
#### 3.2.2. Демографічні змінні
#### 3.2.3. Антропометрія
#### 3.2.4. Артеріальний тиск
#### 3.2.5. Лабораторні показники
#### 3.2.6. Цільові змінні

### 3.3. ETL-процес: підготовка NHANES до health_dataset.csv
#### 3.3.1. Файли та папки, що беруть участь у ETL
#### 3.3.2. Сирі дані
#### 3.3.3. ETL-логіка та скрипти
#### 3.3.4. Конфігурація ETL
#### 3.3.5. Послідовність ETL-процесу
##### 3.3.5.1. Завантаження сирих таблиць
##### 3.3.5.2. Об'єднання таблиць
##### 3.3.5.3. Вибір необхідних колонок
##### 3.3.5.4. Обробка пропусків
##### 3.3.5.5. Фільтрування
##### 3.3.5.6. Перейменування колонок
##### 3.3.5.7. Формування фінального датасету
#### 3.3.6. Перевірка якості підготовлених даних
##### 3.3.6.1. Перевірки на пропуски
##### 3.3.6.2. Перевірка типів даних
##### 3.3.6.3. Перевірка діапазонів
##### 3.3.6.4. Перевірка унікальності ключа SEQN
#### 3.3.7. Роль ETL в магістерському проєкті

## 4. Дослідницький аналіз даних (EDA) (блок 2-EDA)

### 4.1. Вихідні дані для аналізу
### 4.2. Скрипти та інструменти EDA
### 4.3. Основні візуалізації та висновки
#### 4.3.1. Розподіли та описові статистики
#### 4.3.2. Зв'язки між змінними
#### 4.3.3. Аналіз цільових змінних
#### 4.3.4. Текстовий підсумок (summary.txt)
### 4.4. Як результати EDA вплинули на вибір ознак і моделей
### 4.5. Роль EDA в магістерському проєкті

## 5. ML-моделі проєкту (блок 3-ML_MODELS)

### 5.1. Набір моделей
#### 5.1.1. Моделі для прогнозування діабету (diabetes_present)
#### 5.1.2. Моделі для прогнозування ожиріння (obesity_present)
#### 5.1.3. Основні ознаки

### 5.2. Навчання моделей
#### 5.2.1. Скрипти навчання
#### 5.2.2. Pipeline навчання
##### 5.2.2.1. Завантаження даних
##### 5.2.2.2. Підготовка даних
##### 5.2.2.3. Попередня обробка (preprocessing)
##### 5.2.2.4. Навчання моделей
##### 5.2.2.5. Обчислення метрик
##### 5.2.2.6. Збереження артефактів
##### 5.2.2.7. Створення лідерборду
#### 5.2.3. Вибір "Champion Model"

### 5.3. Калібрування моделей
#### 5.3.1. Процес калібрування
#### 5.3.2. Методи калібрування
#### 5.3.3. Артефакти калібрування

### 5.4. Інференс (прогнозування) у API
#### 5.4.1. API endpoints
#### 5.4.2. Завантаження моделей
#### 5.4.3. Pipeline використання

### 5.5. Інтерпретація та фактори ризику
#### 5.5.1. Обчислення важливості ознак
#### 5.5.2. Інтеграція у веб-інтерфейс та PDF

### 5.6. Роль ML-моделей у проєкті

## 6. Технологічний стек (блок 4-TECH_STACK)

### 6.1. Backend
#### 6.1.1. FastAPI
#### 6.1.2. Uvicorn
#### 6.1.3. Starlette
#### 6.1.4. SQLModel та SQLAlchemy
#### 6.1.5. SQLite
#### 6.1.6. Pydantic
#### 6.1.7. JWT (JSON Web Tokens)
#### 6.1.8. OAuth2PasswordBearer
#### 6.1.9. Bcrypt та Passlib
#### 6.1.10. Pillow (PIL)
#### 6.1.11. Requests
#### 6.1.12. Python-multipart

### 6.2. Frontend
#### 6.2.1. Vanilla JavaScript
#### 6.2.2. Chart.js
#### 6.2.3. jsPDF
#### 6.2.4. xlsx-js-style
#### 6.2.5. Navigo
#### 6.2.6. Lucide
#### 6.2.7. Власний i18n модуль
#### 6.2.8. CSS

### 6.3. ML та аналіз даних
#### 6.3.1. Pandas
#### 6.3.2. NumPy
#### 6.3.3. Scikit-learn
#### 6.3.4. XGBoost
#### 6.3.5. Joblib
#### 6.3.6. Matplotlib та Seaborn
#### 6.3.7. PyYAML

### 6.4. База даних та сховище
#### 6.4.1. SQLite
#### 6.4.2. SQLModel ORM
#### 6.4.3. Міграції

### 6.5. Інфраструктура та інструменти розробки
#### 6.5.1. Makefile
#### 6.5.2. Pytest
#### 6.5.3. Pytest-asyncio
#### 6.5.4. Pytest-cov
#### 6.5.5. Httpx
#### 6.5.6. Pyright
#### 6.5.7. Typer

### 6.6. AI-асистент та Ollama
#### 6.6.1. Ollama
#### 6.6.2. Інтеграція з Ollama

### 6.7. Підсумок

## 7. API проєкту (блок 5-API)

### 7.1. Архітектура API
### 7.2. Основні групи ендпоінтів
#### 7.2.1. Прогнозування ризиків (/predict, /explain, /metadata)
#### 7.2.2. Аутентифікація (/auth/*)
#### 7.2.3. Управління користувачами (/users/*)
#### 7.2.4. AI-асистент (/assistant/*)
#### 7.2.5. Чати (/api/chats/*)
#### 7.2.6. Системні ендпоінти (/health, /system/*)

### 7.3. Як API працює з ML-моделями
#### 7.3.1. Зберігання моделей
#### 7.3.2. Завантаження моделей
#### 7.3.3. Pipeline використання
#### 7.3.4. Передача даних до моделі
#### 7.3.5. Повернення оцінки ризику
#### 7.3.6. Визначення factor impact

### 7.4. Як API працює з базою даних
#### 7.4.1. Структура даних
#### 7.4.2. CRUD операції
#### 7.4.3. Інтеграція з ORM

### 7.5. Аутентифікація
#### 7.5.1. JWT токени
#### 7.5.2. Хешування паролів
#### 7.5.3. Захищені та незахищені роути

### 7.6. Генерація PDF/Excel/CSV/JSON на бекенді та фронтенді
#### 7.6.1. Роль бекенду
#### 7.6.2. Роль фронтенду
#### 7.6.3. Формати експорту

### 7.7. Інтеграція API з AI-моделлю Ollama
#### 7.7.1. Архітектура інтеграції
#### 7.7.2. Формування контексту
#### 7.7.3. Виклики Ollama API

### 7.8. API-Status система
#### 7.8.1. Перевірка стану компонентів
#### 7.8.2. Відображення статусів

### 7.9. Формат відповідей API
#### 7.9.1. Структури JSON
#### 7.9.2. Валідація даних

### 7.10. Взаємодія API та фронтенду
#### 7.10.1. SPA архітектура
#### 7.10.2. Обробка помилок

### 7.11. Безпека API
#### 7.11.1. Захист ендпоінтів
#### 7.11.2. Валідація даних
#### 7.11.3. Обмеження доступу

### 7.12. Обмеження та майбутня робота

## 8. Архітектура фронтенду (блок 6-FRONTEND_ARCHITECTURE)

### 8.1. Загальний огляд фронтенду
### 8.2. Структура файлів фронтенду
#### 8.2.1. index.html
#### 8.2.2. app.js
#### 8.2.3. app.css
#### 8.2.4. i18n.js
#### 8.2.5. Локалізація (locales/)
#### 8.2.6. Шрифти та зображення

### 8.3. Архітектура SPA
#### 8.3.1. Принцип роботи SPA
#### 8.3.2. Секції відображаються/ховаються
#### 8.3.3. Маршрути синхронізуються
#### 8.3.4. Ключові концепції

### 8.4. Система маршрутизації (Frontend Routing)
#### 8.4.1. Сторінки системи
#### 8.4.2. Публічні та захищені сторінки
#### 8.4.3. Guard-и для автентифікації

### 8.5. Управління станом (State Management)
#### 8.5.1. authState
#### 8.5.2. chatState
#### 8.5.3. modelResultsState
#### 8.5.4. diagramState
#### 8.5.5. reportState
#### 8.5.6. apiStatusState

### 8.6. Робота з API
#### 8.6.1. Fetch-запити
#### 8.6.2. Обробка помилок
#### 8.6.3. Управління токенами

### 8.7. Генерація PDF-звітів
#### 8.7.1. Використання jsPDF
#### 8.7.2. Вбудовування діаграм
#### 8.7.3. Підтримка кирилиці

### 8.8. Діаграми (Charts)
#### 8.8.1. Використання Chart.js
#### 8.8.2. Типи діаграм
#### 8.8.3. Експорт у PDF

### 8.9. AI-асистент (Ollama Frontend UI)
#### 8.9.1. Чат-інтерфейс
#### 8.9.2. Інтеграція з API
#### 8.9.3. Відображення статусів

### 8.10. UI/UX архітектура
#### 8.10.1. Система секцій та сторінок
#### 8.10.2. Модальні вікна
#### 8.10.3. Анімації та переходи
#### 8.10.4. Адаптивність

### 8.11. Стилі
#### 8.11.1. Архітектура CSS
#### 8.11.2. Темна та світла теми
#### 8.11.3. BEM-подібна методологія

### 8.12. Система локалізації
#### 8.12.1. JSON-файли перекладів
#### 8.12.2. Динамічна підміна текстів
#### 8.12.3. Підтримка мов

### 8.13. Тести для фронтенду (архітектурний огляд)
### 8.14. Майбутні покращення

## 9. Архітектура бекенду (блок 7-BACKEND_ARCHITECTURE)

### 9.1. Загальний огляд бекенду
### 9.2. Структура файлів бекенду
#### 9.2.1. api.py
#### 9.2.2. routers/
#### 9.2.3. routes_auth.py
#### 9.2.4. schemas.py
#### 9.2.5. models.py
#### 9.2.6. db.py
#### 9.2.7. repositories.py
#### 9.2.8. auth_utils.py
#### 9.2.9. model_registry.py
#### 9.2.10. services/assistant_llm.py
#### 9.2.11. avatar_utils.py
#### 9.2.12. i18n.py

### 9.3. ASGI / FastAPI архітектура
#### 9.3.1. Запуск сервісу
#### 9.3.2. ASGI lifecycle
#### 9.3.3. Робота event loop
#### 9.3.4. Інтеграція FastAPI з фронтендом
#### 9.3.5. Middleware

### 9.4. Архітектура маршрутів (Routers)
#### 9.4.1. auth_router
#### 9.4.2. users_router
#### 9.4.3. assistant_router
#### 9.4.4. chats_router
#### 9.4.5. Системні ендпоінти

### 9.5. Система аутентифікації
#### 9.5.1. JWT токени
#### 9.5.2. Хешування паролів
#### 9.5.3. Dependency injection
#### 9.5.4. Механізм refresh токенів

### 9.6. Взаємодія бекенду з ML-моделями
#### 9.6.1. Зберігання моделей
#### 9.6.2. Завантаження моделей
#### 9.6.3. Обробка вхідних даних
#### 9.6.4. Виконання прогнозування
#### 9.6.5. Обчислення факторів впливу

### 9.7. Робота з базою даних
#### 9.7.1. ORM та структура БД
#### 9.7.2. CRUD операції
#### 9.7.3. Управління сесіями
#### 9.7.4. Обробка помилок

### 9.8. Обробка історії прогнозів
#### 9.8.1. Збереження прогнозів
#### 9.8.2. Отримання історії
#### 9.8.3. Статистика

### 9.9. API статуси (API-Status System)
#### 9.9.1. Перевірка стану компонентів
#### 9.9.2. Агрегація статусів

### 9.10. Chat API
#### 9.10.1. Створення чатів
#### 9.10.2. Управління повідомленнями
#### 9.10.3. Блокування користувачів

### 9.11. AI-Assistant API (Ollama)
#### 9.11.1. Інтеграція з Ollama
#### 9.11.2. Формування контексту
#### 9.11.3. Обробка відповідей

### 9.12. Error handling
#### 9.12.1. Глобальна обробка помилок
#### 9.12.2. Форматування відповідей
#### 9.12.3. Статус-коди

### 9.13. Безпека
#### 9.13.1. CORS контроль
#### 9.13.2. JWT безпека
#### 9.13.3. Хешування паролів
#### 9.13.4. Валідація даних

### 9.14. Майбутні покращення

## 10. База даних (блок 8-DATABASE)

### 10.1. Загальний огляд
#### 10.1.1. Тип БД
#### 10.1.2. Основні задачі БД
#### 10.1.3. Роль БД як центрального сховища стану

### 10.2. Технології та інструменти для роботи з БД
#### 10.2.1. Бібліотеки для роботи з БД
#### 10.2.2. Основний код роботи з БД
#### 10.2.3. Організація підключення до БД
#### 10.2.4. Life-cycle сесій у запитах

### 10.3. Фізичне розташування БД
#### 10.3.1. Де зберігається файл БД
#### 10.3.2. Створення БД автоматично
#### 10.3.3. Скрипти для ініціалізації / міграцій

### 10.4. Основні таблиці та їх призначення
#### 10.4.1. Таблиця користувачів (user)
#### 10.4.2. Таблиця історії прогнозів (predictionhistory)
#### 10.4.3. Таблиця чатів (chat)
#### 10.4.4. Таблиця повідомлень (chatmessage)
#### 10.4.5. Таблиця повідомлень AI-асистента (assistantmessage)
#### 10.4.6. Таблиця заблокованих користувачів (userblock)
#### 10.4.7. Таблиця токенів відновлення пароля (passwordresettoken)

### 10.5. Зв'язки між таблицями
#### 10.5.1. User ↔ PredictionHistory
#### 10.5.2. User ↔ AssistantMessage
#### 10.5.3. User ↔ Chat
#### 10.5.4. Chat ↔ ChatMessage
#### 10.5.5. User ↔ UserBlock
#### 10.5.6. Інші зв'язки

### 10.6. Управління транзакціями
#### 10.6.1. Як відкривається сесія для запиту
#### 10.6.2. Як commit/rollback організовано
#### 10.6.3. Контекстні менеджери / dependency injection
#### 10.6.4. Цілісність даних при помилках

### 10.7. Продуктивність та масштабованість
#### 10.7.1. Індекси на ключових полях
#### 10.7.2. Які таблиці ростуть найшвидше
#### 10.7.3. Що буде важливим для масштабування

### 10.8. Як різні модулі системи використовують базу даних
#### 10.8.1. Модуль аутентифікації
#### 10.8.2. Модуль прогнозів
#### 10.8.3. Модуль чатів
#### 10.8.4. Модуль API-status
#### 10.8.5. Модуль блокувань
#### 10.8.6. Модуль AI-асистента

### 10.9. Безпека даних
#### 10.9.1. Як зберігаються паролі
#### 10.9.2. Відсутність зберігання "чистих" паролів
#### 10.9.3. Можлива анонімізація чутливих медичних даних
#### 10.9.4. Обмеження доступу через auth-рівень

### 10.10. Можливі напрямки покращення схеми БД
#### 10.10.1. Перехід на більш потужну СУБД
#### 10.10.2. Виділення логів у окрему таблицю/схему
#### 10.10.3. Додавання audit log
#### 10.10.4. Оптимізація індексів
#### 10.10.5. Розділення data warehouse та онлайн-схеми

## 11. Тестування (блок 9-TESTING)

### 11.1. Загальний огляд
#### 11.1.1. Рівні тестування
#### 11.1.2. Призначення тестів
#### 11.1.3. Фізичне розташування тестів

### 11.2. Структура тестового каталогу
#### 11.2.1. Коренева папка tests/
#### 11.2.2. Підпапка tests/backend/
#### 11.2.3. Підпапка tests/frontend/
#### 11.2.4. Підпапка tests/ml/
#### 11.2.5. Підпапка tests/utils/
#### 11.2.6. Файл conftest.py

### 11.3. Інструменти та фреймворки тестування
#### 11.3.1. Pytest
#### 11.3.2. Pytest-asyncio
#### 11.3.3. Pytest-cov
#### 11.3.4. Httpx
#### 11.3.5. Frontend тестові інструменти

### 11.4. Unit тести
#### 11.4.1. Модулі, що покриваються unit тестами
#### 11.4.2. Розташування unit тестів
#### 11.4.3. Типові сценарії, що перевіряються

### 11.5. Інтеграційні тести
#### 11.5.1. Компоненти, що перевіряють інтеграційні тести
#### 11.5.2. Розташування інтеграційних тестів
#### 11.5.3. Організація підготовки середовища

### 11.6. Тестування ML моделей
#### 11.6.1. Розташування ML тестів
#### 11.6.2. Аспекти, що перевіряються

### 11.7. Тестування API
#### 11.7.1. Ендпоінти, що покриваються тестами
#### 11.7.2. Як тести формують HTTP запити
#### 11.7.3. Як тести перевіряють статус код
#### 11.7.4. Як тести перевіряють структуру JSON-відповіді
#### 11.7.5. Як тести перевіряють сценарії з помилками

### 11.8. Тестування фронтенду
#### 11.8.1. Статус фронтенд тестів
#### 11.8.2. Майбутні інструменти

### 11.9. Експериментальні тести та нестандартні сценарії
#### 11.9.1. Розташування експериментальних тестів
#### 11.9.2. Що перевіряють експериментальні тести
#### 11.9.3. Як допомагають підтвердити надійність системи

### 11.10. Запуск тестів та конфігурація
#### 11.10.1. Як запустити всі тести одним рядком
#### 11.10.2. Окремі задачі для різних типів тестів
#### 11.10.3. Використання coverage

### 11.11. Покриття та якість
#### 11.11.1. Вимірювання coverage
#### 11.11.2. Частини системи, покриті тестами найкраще
#### 11.11.3. Частини системи, покриті гірше або ще не покриті
#### 11.11.4. Як тести інтегруються з процесом розробки

### 11.12. Можливі напрямки розвитку системи тестування

## 12. Структура проєкту (блок STRUCTURE)

### 12.1. Загальна структура директорій
### 12.2. Ключові папки та файли
#### 12.2.1. artifacts/
#### 12.2.2. configs/
#### 12.2.3. data/
#### 12.2.4. datasets/
#### 12.2.5. scripts/
#### 12.2.6. src/
#### 12.2.7. tests/
#### 12.2.8. docs/

## 13. Обмеження та поточний стан системи

### 13.1. Технічні обмеження
#### 13.1.1. Обмеження SQLite
#### 13.1.2. Обмеження локального Ollama
#### 13.1.3. Обмеження фронтенду
#### 13.1.4. Обмеження ML-моделей

### 13.2. Функціональні обмеження
#### 13.2.1. Підтримувані цільові змінні
#### 13.2.2. Обмеження датасету
#### 13.2.3. Обмеження інтерфейсу

### 13.3. Поточний стан розробки
#### 13.3.1. Реалізовані функції
#### 13.3.2. Функції в розробці
#### 13.3.3. Відомі проблеми

## 14. Майбутній розвиток

### 14.1. Розширення ML-моделей
#### 14.1.1. Додавання нових цільових змінних
#### 14.1.2. Покращення існуючих моделей
#### 14.1.3. Інтеграція нових алгоритмів

### 14.2. Покращення архітектури
#### 14.2.1. Масштабування для продакшену
#### 14.2.2. Мікросервісна архітектура
#### 14.2.3. Оптимізація продуктивності

### 14.3. Розширення функціональності
#### 14.3.1. Додаткові типи звітів
#### 14.3.2. Покращення AI-асистента
#### 14.3.3. Розширення системи чатів

### 14.4. Покращення тестування
#### 14.4.1. Покриття фронтенду тестами
#### 14.4.2. E2E тести
#### 14.4.3. Стес-тести

### 14.5. Інфраструктура
#### 14.5.1. CI/CD
#### 14.5.2. Моніторинг та логування
#### 14.5.3. Резервне копіювання

## 15. Висновки

### 15.1. Підсумок проєкту
### 15.2. Досягнення
### 15.3. Вклад у магістерську роботу
### 15.4. Перспективи розвитку

