# Частина 3: Frontend та UI/UX

## 8. Frontend (Web Interface)

### 8.1. Загальний огляд

Фронтенд проєкту HealthRisk.AI є центральним інтерфейсом взаємодії користувачів з системою прогнозування ризиків здоров'я. Він реалізований як Single Page Application (SPA) на чистому JavaScript без використання фреймворків, що забезпечує мінімалістичний, автономний та легкий клієнт з повною функціональністю системи.

**Що таке frontend у проєкті** — фронтенд є клієнтською частиною веб-додатку, яка відповідає за відображення інтерфейсу користувача, обробку взаємодії, комунікацію з API та генерацію звітів. Він працює повністю в браузері користувача та не потребує серверного рендерингу, що робить його швидким та масштабованим. Фронтенд інтегрується з усіма компонентами системи: API для отримання даних та виконання операцій, ML-моделями через API для прогнозування ризиків, базою даних через API для збереження історії та профілів, Ollama через API для AI-асистента.

**Які технології використовуються** — фронтенд побудований на нативних веб-технологіях: HTML5 для структури сторінки, CSS3 для стилізації та анімацій, Vanilla JavaScript (ES6+) для логіки та інтерактивності. Додатково використовуються зовнішні бібліотеки: Chart.js для побудови діаграм, jsPDF для генерації PDF-звітів, xlsx-js-style для експорту в Excel, Navigo для маршрутизації, Lucide для іконок. Всі бібліотеки завантажуються з CDN, що спрощує розгортання та оновлення. Власні модулі (i18n.js для локалізації, app.js для основної логіки) завантажуються з сервера та інтегруються з HTML.

**Чому саме vanilla JS + HTML/CSS без фреймворків** — вибір нативних технологій без фреймворків обумовлений кількома факторами: простота розробки — відсутність необхідності налаштування системи збірки (Webpack, Vite) спрощує розробку та тестування; легкість підтримки — код без абстракцій фреймворків легше зрозуміти та модифікувати; швидкість завантаження — відсутність великих бібліотек фреймворків зменшує розмір завантажуваних файлів та прискорює перше завантаження сторінки; повний контроль — розробник має повний контроль над поведінкою додатку без обмежень фреймворків; мінімальні залежності — менша кількість залежностей зменшує ризик конфліктів версій та проблем сумісності; навчальна мета — для магістерського проєкту важливо продемонструвати розуміння основ веб-розробки без покладання на готові рішення.

**Архітектура SPA** — Single Page Application працює через один HTML-файл, який містить всі секції сторінок у прихованому стані. При завантаженні сторінки бекенд завжди повертає один і той самий HTML-файл незалежно від URL, а JavaScript визначає, яку секцію потрібно показати на основі поточного URL. Всі секції присутні в DOM з самого початку, але приховані через CSS-класи та атрибут `hidden`, що дозволяє швидко перемикатися між сторінками без додаткових HTTP-запитів. Перемикання секцій виконується через додавання класу `page--active` та видалення атрибута `hidden` для активної секції та приховування всіх інших.

**Перехоплення роутів без перезавантаження** — навігація між сторінками виконується без перезавантаження сторінки через History API браузера. При кліку на посилання або програмній зміні маршруту JavaScript перехоплює подію, оновлює URL через `history.pushState()` або `history.replaceState()`, активує відповідну секцію та оновлює інтерфейс. При використанні кнопок "Назад" та "Вперед" браузера спрацьовує обробник події `popstate`, який синхронізує стан SPA з URL. Це забезпечує плавну навігацію без затримок перезавантаження та зберігає історію перегляду для користувача.

### 8.2. Структура фронтенду

Фронтенд організований у директорії `src/service/web/` з чітким розділенням відповідальності між файлами та модулями.

**index.html** — це кореневий HTML-файл, який містить структуру всієї сторінки. Він включає всі секції сторінок (форма прогнозування, історія, діаграми, профіль, чати, асистент, API-status тощо) у прихованому стані, sidebar з навігацією, модальні вікна, overlay-и для завантаження та інші UI-компоненти. HTML містить всі необхідні елементи для роботи SPA, включаючи атрибути для локалізації (`data-i18n`), іконки Lucide (`data-lucide`) та структуровані дані для доступу через JavaScript. Всі бібліотеки завантажуються через теги `<script>` у `<head>`, а власні модулі завантажуються з атрибутом `defer` для забезпечення правильного порядку ініціалізації.

**app.js (величезний orchestrator)** — це основний файл логіки SPA, який містить всю бізнес-логіку фронтенду. Файл має приблизно 14667 рядків коду та включає: управління станом (authState для автентифікації, predictionStore для результатів прогнозів, diagramState для діаграм, chatState для чатів, apiStatusState для моніторингу); систему маршрутизації (ROUTE_SECTIONS для мапінгу URL на секції, normalizePath для нормалізації шляхів, showSectionForPath для активації секцій, syncRouteFromLocation для синхронізації з URL); роботу з API (apiFetch для HTTP-запитів, обробка відповідей, валідація даних, обробка помилок); генерацію PDF-звітів (generatePDFReport, експорт діаграм, форматування тексту, підтримка кирилиці); роботу з діаграмами Chart.js (створення, оновлення, експорт); інтеграцію з AI-асистентом (відправка повідомлень, відображення відповідей, збереження історії); обробку форм (валідація, відправка, відображення результатів); всю інтерактивність користувача (кліки, натискання клавіш, зміна тем, перемикання sidebar).

**app.css** — це глобальні стилі для всього додатку, які визначають вигляд всіх компонентів, тем (світла/темна), анімації, адаптивність та типографіку. CSS організований за принципом BEM-подібної методології з використанням модифікаторів та вкладених селекторів. Стилі включають CSS-змінні для тем (кольори, градієнти, тіні, прозорість), нормалізацію браузерних стилів, стилі компонентів (sidebar, forms, charts, modals, tooltips), стилі секцій сторінок, анімації та transitions, адаптивні стилі через media queries та утилітарні класи для спінерів, badges та інших елементів.

**Папки компонентів** — хоча фронтенд не використовує компонентну архітектуру фреймворків, логіка організована функціонально через функції у `app.js`, які відповідають за конкретні компоненти. Компоненти включають форми (форма прогнозування, форма входу, форма реєстрації, форма профілю), діаграми (Chart.js інстанси для різних типів графіків), модальні вікна (підтвердження дій, налаштування, інформація), нотифікації (toast-сповіщення для успіхів, помилок, інформації), sidebar (навігація, перемикання теми, статуси), чати (список чатів, детальний вигляд чату, повідомлення), AI-асистент (інтерфейс чату, історія повідомлень).

**Папки сторінок (page-*)** — всі сторінки реалізовані як секції в HTML з унікальними ID, які відповідають префіксу `page-`. Секції включають `page-form` для форми прогнозування, `page-history` для історії прогнозів, `page-insights` для діаграм та аналітики, `page-profile` для профілю користувача, `page-assistant` для AI-асистента, `page-chats` для системи чатів, `page-report` для звітів, `page-api-status` для моніторингу системи, `page-login` для входу, `page-register` для реєстрації, `page-about` для інформації про систему. Кожна секція містить свою структуру HTML, яка активується через JavaScript при навігації.

**Папка графіків** — діаграми реалізовані через Chart.js та зберігаються у об'єкті `dashboardCharts` для швидкого доступу та управління. Кожна діаграма має унікальний ID (наприклад, `chart-risk-diabetes`, `chart-risk-obesity`, `chart-factors`, `chart-distributions`, `chart-correlations`, `chart-age`, `chart-history`) та створюється через функцію `upsertDashboardChart()`, яка створює новий інстанс Chart.js або оновлює існуючий. Діаграми автоматично оновлюються при зміні даних та експортуються у PDF через конвертацію canvas у зображення.

**Папка PDF** — генерація PDF реалізована через функції у `app.js`, які використовують jsPDF для створення документів. Функції включають `generatePDFReport()` для генерації основного звіту, `renderCoverPage()` для обкладинки, `renderContentPage()` для основного контенту, `exportChartsToPDF()` для експорту діаграм, `ensurePdfFontInitialized()` для завантаження шрифтів кирилиці. PDF генерується повністю на клієнті без завантаження на сервер, що забезпечує швидкість та конфіденційність даних.

**Основна логіка: state management** — управління станом реалізовано через JavaScript-об'єкти без використання спеціалізованих бібліотек. Головні об'єкти стану включають `authState` для автентифікації (token, user, history, initialized), `predictionStore` для результатів прогнозів (зберігається за ключами), `dashboardCharts` для діаграм (зберігаються інстанси Chart.js), `chatState` для чатів (вибраний чат, список користувачів, непрочитані повідомлення), `apiStatusState` для моніторингу (статуси API, БД, Ollama, історія статусів). Стан оновлюється синхронно через прямі зміни об'єктів та зберігається в LocalStorage для персистентних даних (токен, налаштування теми, стан sidebar).

**Основна логіка: event bus** — хоча фронтенд не використовує формальний event bus, комунікація між компонентами виконується через глобальні функції та події браузера. Події включають `popstate` для навігації через історію браузера, `resize` для адаптації діаграм до розміру вікна, `click` для взаємодії користувача, `submit` для відправки форм, `keydown` для обробки клавіатури (наприклад, Escape для закриття модальних вікон). Функції викликаються безпосередньо з обробників подій або через делегування подій на батьківських елементах.

**Основна логіка: router (внутрішній)** — маршрутизація реалізована через власну систему без використання зовнішніх бібліотек (Navigo використовується тільки як допоміжна утиліта). Система включає об'єкт `ROUTE_SECTIONS` для мапінгу URL на ID секцій, функцію `normalizePath()` для нормалізації шляхів (видалення подвійних слешів, обробка аліасів, конвертація в нижній регістр), функцію `getSectionByPath()` для визначення секції за URL, функцію `showSectionForPath()` для активації секції з перевіркою автентифікації, функцію `syncRouteFromLocation()` для синхронізації стану з URL, функцію `activateSection()` для активації конкретної секції з оновленням навігації та локалізації.

**Основна логіка: система ініціалізації сторінок** — ініціалізація сторінок виконується через функцію `activateSection()`, яка викликається при навігації. Функція виконує кілька кроків: видаляє клас `page--active` з усіх секцій та додає атрибут `hidden`, додає клас `page--active` до цільової секції та видаляє атрибут `hidden`, оновлює активний стан навігації у sidebar (додає клас `nav-item--active` до відповідного пункту меню), застосовує локалізацію до елементів секції через `applyTranslations()`, викликає специфічні функції ініціалізації для деяких сторінок (наприклад, `initializeInsights()` для діаграм, `loadChatsList()` для чатів, `loadApiStatus()` для API-status). Це забезпечує, що кожна сторінка правильно ініціалізується при активації.

### 8.3. UI/UX логіка

UI/UX архітектура фронтенду організована через систему компонентів, анімацій та адаптивності для забезпечення зручного та інтуїтивного інтерфейсу.

**Notification system** — система сповіщень реалізована через функцію `showNotification()`, яка створює toast-сповіщення у правому верхньому куті екрана. Сповіщення підтримують три типи: `success` для успішних операцій (зелена ліва межа, іконка check-circle), `error` для помилок (червона ліва межа, іконка alert-circle), `info` для інформаційних повідомлень (синя ліва межа, іконка info). Сповіщення автоматично зникають через заданий час (за замовчуванням 5 секунд) або можуть бути закриті вручну через кнопку закриття. Система обмежує кількість одночасних сповіщень (максимум 4), автоматично видаляючи найстаріші при перевищенні ліміту. Сповіщення мають анімацію появи (slide in зправа) та зникнення (slide out вправо) для плавності. Кожне сповіщення має заголовок та опційне повідомлення, підтримує ARIA-атрибути для доступності та автоматично оновлює іконки Lucide після створення.

**Custom tooltips** — tooltip-и реалізовані через CSS псевдоелемент `::after` для елементів з атрибутом `data-tooltip`. Tooltip-и особливо важливі для згорнутого стану sidebar, де текст навігації прихований, а tooltip-и показують назву пункту меню при наведенні. Tooltip-и мають напівпрозорий фон з blur-ефектом, тінь для глибини, плавну анімацію появи (fade in + slide) та автоматичне позиціювання відносно елемента. Tooltip-и також використовуються для кнопок, іконок та інших інтерактивних елементів для надання додаткової інформації користувачам.

**Dynamic modals** — модальні вікна реалізовані через HTML-структури з класом `modal` та overlay з класом `modal__backdrop`. Модальні вікна використовуються для підтвердження дій (видалення прогнозів, очищення історії, вихід з акаунту), налаштувань (тема, мова), інформації (про систему, про ризики) та помилок. Модальні вікна мають анімацію появи (fade in для overlay, slide up + scale для контейнера) та зникнення (fade out + slide down), закриваються при кліку поза ними, натисканні клавіші Escape або кнопки закриття. Модальні вікна мають напівпрозорий backdrop з blur-ефектом, центрований контейнер з контентом, кнопки дій (primary для підтвердження, secondary для скасування) та підтримують фокус-трап для доступності.

**Sidebar animation + expand/collapse** — sidebar має функціональність згортання/розгортання через кнопку toggle у верхній частині. При згортанні sidebar зменшує ширину, приховує текст навігації, зберігає тільки іконки та змінює іконку toggle з `panel-left-close` на `panel-left-open`. Стан sidebar зберігається в LocalStorage під ключем `hr_sidebar_collapsed` та відновлюється при завантаженні сторінки. Анімація виконується через CSS transitions для плавності зміни ширини, padding, gap та opacity. При згортанні sidebar використовує tooltip-и для показу назв пунктів меню при наведенні. Layout автоматично адаптується до стану sidebar через клас `layout--sidebar-collapsed`, який змінює grid-template-columns для правильного розміщення контенту.

**Header adaptive logic** — header (якщо присутній) адаптується до розміру екрана через CSS media queries. На мобільних пристроях header може згортатися, приховувати деякі елементи або змінювати розмір шрифтів та відступів. Header також може містити індикатори стану (наприклад, кількість непрочитаних повідомлень, статус API) та адаптувати їх відображення залежно від доступного простору.

**Логіка блокування користувачів** — блокування користувачів реалізовано через ендпоінти API `/users/block` та `/users/unblock`, які створюють або видаляють записи у таблиці `userblock`. На фронтенді блокування доступне через профіль користувача, де можна заблокувати або розблокувати іншого користувача. Заблоковані користувачі не можуть створювати чати, відправляти повідомлення та бачитися в активних чатах. UI відображає статус блокування через індикатори та обмежує взаємодію з заблокованими користувачами. Блокування перевіряється на бекенді при створенні чатів, відправці повідомлень та отриманні списку користувачів.

**Анімації крапочок «Перевірка...»** — анімація "Перевірка..." використовується для індикації очікування відповіді від Ollama під час генерації AI-відповіді. Анімація реалізована через JavaScript, який додає крапки поступово (".", "..", "...") з інтервалом приблизно 500 мілісекунд. Анімація запускається перед відправкою запиту до API та зупиняється при отриманні відповіді або помилки. Це забезпечує візуальний індикатор того, що система обробляє запит та генерує відповідь.

**Динамічна зміна стилів теми** — перемикання теми (світла/темна) реалізується через зміну класу `theme-light` або `theme-dark` на елементі `<body>`. CSS-змінні автоматично оновлюються залежно від класу, що змінює кольори, градієнти, тіні та прозорість всіх компонентів. Тема зберігається в LocalStorage під ключем `hr_theme` та відновлюється при завантаженні сторінки. Перемикання теми виконується через кнопку у sidebar, яка змінює клас на body, оновлює іконку (sun для світлої теми, moon для темної) та зберігає вибір у LocalStorage. Перехід між темами має плавну анімацію через CSS transitions для всіх кольорів та фонів.

### 8.4. Навігація та SPA-механіка

Система навігації фронтенду забезпечує плавну навігацію між сторінками без перезавантаження через History API та синхронізацію стану з URL.

**Що таке syncRouteFromLocation()** — це функція, яка синхронізує стан SPA з поточним URL у браузері. Вона викликається при завантаженні сторінки, зміні URL через History API (кнопки "Назад"/"Вперед") або програмній зміні маршруту. Функція отримує поточний `pathname` з `window.location`, викликає `showSectionForPath()` для активації відповідної секції та оновлює URL через `history.replaceState()`, якщо шлях змінився. Це забезпечує, що URL завжди відповідає активній секції та дозволяє використовувати кнопки браузера для навігації по історії SPA.

**Як працює showSectionForPath()** — це основна функція навігації, яка визначає та активує секцію на основі URL. Функція виконує кілька кроків: нормалізує шлях через `normalizePath()` (видаляє подвійні слеші, обробляє аліаси, конвертує в нижній регістр), визначає секцію через `getSectionByPath()` (знаходить відповідну секцію в `ROUTE_SECTIONS`), перевіряє автентифікацію для захищених маршрутів (якщо користувач не залогінений та маршрут не публічний, викликає `handleUnauthorized()` та перенаправляє на `/login`), перевіряє ініціалізацію автентифікації (якщо автентифікація ще не ініціалізована, чекає та повертає шлях для подальшої обробки), активує секцію через `activateSection()` (додає клас `page--active`, видаляє атрибут `hidden`, оновлює навігацію), повертає фінальний шлях для оновлення URL. Функція також обробляє спеціальні випадки, такі як редірект залогінених користувачів з `/login` на `/app` та обробка маршрутів з параметрами (наприклад, `/c/{chat_uuid}`, `/reset-password?token=...`).

**Як працюють публічні та захищені маршрути** — маршрути розділені на публічні (доступні без автентифікації) та захищені (вимагають автентифікації). Публічні маршрути включають `/login`, `/register`, `/forgot-password`, `/reset-password`, `/about` та визначаються через функцію `isPublicRoute()`. Захищені маршрути включають всі інші сторінки (`/app`, `/diagrams`, `/history`, `/profile`, `/assistant`, `/chats`, `/reports`, `/api-status`) та визначаються через список `protectedSections`. При спробі доступу до захищеного маршруту без автентифікації користувач автоматично перенаправляється на `/login` через `handleUnauthorized()`. При спробі доступу залогіненого користувача до публічних маршрутів (наприклад, `/login` або `/register`) він автоматично перенаправляється на `/app` для зручності.

**Як логіка визначає, куди пускати / куди редіректити** — логіка визначення маршруту виконується через кілька перевірок у `showSectionForPath()`: перевірка автентифікації (якщо користувач не залогінений та маршрут не публічний → редірект на `/login`), перевірка ініціалізації (якщо автентифікація ще не ініціалізована → чекаємо, поки ініціалізується), перевірка валідності маршруту (якщо маршрут не існує в `ROUTE_SECTIONS` → редірект на `/app` для залогінених або `/login` для незалогінених), перевірка стану користувача (якщо залогінений користувач на `/login` або `/register` → редірект на `/app`), активація секції (якщо всі перевірки пройдені → активуємо секцію та залишаємося на маршруті). Логіка також зберігає цільовий маршрут у `pendingRouteAfterAuth` для повернення після входу, якщо користувач намагався отримати доступ до захищеного маршруту без автентифікації.

**Взаємодія з localStorage** — LocalStorage використовується для зберігання персистентних даних, які повинні зберігатися між сесіями. Ключові дані, що зберігаються: `hr_auth_token` для JWT-токена автентифікації, `hr_sidebar_collapsed` для стану sidebar (згорнутий/розгорнутий), `hr_theme` для вибраної теми (light/dark), `hr_history_view` для режиму перегляду історії (list/grid), `hr_assistant_selected_prediction_{userId}` для вибраного прогнозу в асистенті, `hr_assistant_latest_ts_{userId}` для останнього timestamp в асистенті. Дані зчитуються при завантаженні сторінки та використовуються для відновлення стану (автентифікація, налаштування, вибір користувача). Дані оновлюються при зміні стану (вхід/вихід, зміна теми, зміна стану sidebar) та видаляються при необхідності (вихід з акаунту очищає токен).

### 8.5. Взаємодія з API

Взаємодія фронтенду з API організована через централізовану функцію `apiFetch()`, яка інкапсулює всі HTTP-запити та забезпечує обробку помилок, додавання токенів та парсинг відповідей.

**Принцип асинхронних викликів** — всі API-запити виконуються асинхронно через `async/await` для неблокуючої обробки. Функція `apiFetch()` приймає шлях ендпоінта, опції HTTP (method, body, headers) та опції обробки (skipAuth, skipAuthCheck) та повертає Promise з даними відповіді. Використання `async/await` дозволяє писати код у синхронному стилі з обробкою помилок через `try/catch`, що спрощує читабельність та підтримку. Всі запити виконуються через нативний API `fetch()`, який підтримується всіма сучасними браузерами та забезпечує швидкість та надійність.

**Валідація відповідей** — валідація відповідей виконується на кількох рівнях: перевірка статусу відповіді (якщо `!response.ok`, обробляється як помилка), перевірка Content-Type (якщо відповідь містить `application/json`, парситься як JSON, інакше обробляється як текст), перевірка структури даних (очікується структурована відповідь згідно з Pydantic-схемами API), обробка помилок парсингу (якщо JSON невалідний, повертається помилка з зрозумілим повідомленням). Валідація забезпечує, що фронтенд отримує коректні дані та може правильно їх обробити.

**Помилки API** — обробка помилок виконується централізовано через `apiFetch()` з різною логікою для різних статус-кодів: 401 (Unauthorized) → автоматичне очищення токена, видалення користувача зі стану, перенаправлення на `/login` через `handleUnauthorized()`, 400 (Bad Request) → відображення повідомлення про помилку через нотифікацію, 403 (Forbidden) → відображення повідомлення про відсутність доступу, 404 (Not Found) → відображення повідомлення про відсутність ресурсу, 422 (Unprocessable Entity) → відображення деталей помилки валідації, 500 (Internal Server Error) → відображення загального повідомлення про помилку сервера. Всі помилки логуються в консоль для діагностики та відображаються користувачу через систему нотифікацій з детальними повідомленнями.

**Автоматичне оновлення UI після відповідей** — після успішних API-запитів UI автоматично оновлюється через виклик відповідних функцій рендерингу. Наприклад, після успішного прогнозування викликається `renderResult()` для відображення результатів, після завантаження історії викликається `renderHistoryTable()` для оновлення таблиці, після оновлення профілю викликається `updateProfileSection()` для відображення нових даних, після завантаження чатів викликається `renderChatsList()` для оновлення списку. Це забезпечує, що UI завжди відображає актуальні дані після операцій та користувач бачить результати своїх дій.

**Використання токенів** — JWT-токени використовуються для автентифікації всіх захищених API-запитів. Токен зберігається в LocalStorage під ключем `hr_auth_token` після успішного входу або реєстрації та автоматично додається до всіх API-запитів через заголовок `Authorization: Bearer <token>` у функції `apiFetch()`. Токен перевіряється при завантаженні сторінки через ендпоінт `/auth/me` для відновлення сесії користувача. При отриманні помилки 401 токен автоматично видаляється з LocalStorage та стану, користувач перенаправляється на `/login`. Токен також використовується для опційної автентифікації на деяких ендпоінтах (наприклад, `/predict`), де запит може виконуватися без токена, але зберігається в історії тільки для автентифікованих користувачів.

### 8.6. Формування PDF на фронтенді

Генерація PDF-звітів виконується повністю на фронтенді через бібліотеку jsPDF, що забезпечує швидкість, конфіденційність даних та гнучкість форматування.

**Чому jsPDF** — jsPDF обрано для генерації PDF через кілька переваг: повна клієнтська обробка — PDF генерується в браузері без завантаження даних на сервер, що забезпечує конфіденційність та швидкість; простота використання — бібліотека має інтуїтивний API для створення документів, додавання тексту, зображень та форматування; підтримка кирилиці — через завантаження спеціальних шрифтів (DejaVuSans) можна генерувати PDF з українським текстом; інтеграція з Chart.js — діаграми можуть бути легко експортовані у зображення та вставлені в PDF; легкість розгортання — бібліотека завантажується з CDN, не потребує налаштування сервера; гнучкість — можна повністю контролювати структуру, стилі та вміст PDF.

**Чому PDF на фронтенді, а не на бекенді** — генерація PDF на фронтенді має кілька переваг: зменшення навантаження на сервер — генерація виконується на клієнті, що зменшує навантаження на сервер та дозволяє обробляти більше одночасних запитів; швидкість — генерація на клієнті забезпечує швидкий відгук без очікування обробки на сервері; конфіденційність — дані не передаються на сервер для генерації, що забезпечує додатковий рівень конфіденційності; гнучкість — фронтенд може легко змінювати формат звітів без змін на сервері; масштабованість — генерація на клієнті не обмежує кількість одночасних запитів на генерацію звітів; відсутність залежності від сервера — PDF може генеруватися навіть при обмеженій доступності сервера. Недоліками є залежність від можливостей браузера та необхідність завантаження додаткових бібліотек на клієнті.

**Як формується структура PDF** — структура PDF формується через функцію `generatePDFReport()`, яка створює документ у форматі A4 (210x297 мм) та додає контент поетапно. Структура включає: обкладинку (`renderCoverPage()`) з назвою системи, іконкою, датою генерації та темою (світла/темна), основну сторінку (`renderContentPage()`) з інформацією про прогноз (цільова змінна, ймовірність, категорія ризику), топ факторами впливу, рекомендаціями та технічними деталями, діаграми (`exportChartsToPDF()`) з експортованими графіками Chart.js у форматі PNG, додаткові сторінки (якщо потрібно) з детальною статистикою, історією прогнозів або іншою інформацією. Кожна сторінка має відступи (margins), внутрішні відступи (inner margins) та автоматичне перенесення тексту для оптимального розміщення контенту.

**Генерація графіків (canvas → PNG → PDF)** — експорт діаграм у PDF виконується через конвертацію canvas-елементів у зображення. Процес включає кілька кроків: отримання canvas-елементів для всіх діаграм на сторінці через їхні ID, тимчасове показування прихованих canvas (якщо діаграми на неактивній сторінці), збереження початкового стану canvas (display, visibility, hidden) для відновлення після експорту, експорт canvas у PNG через метод `toDataURL('image/png')` з високою роздільною здатністю, масштабування зображень для вміщення на сторінку A4 з збереженням пропорцій, вставка зображень у PDF через `doc.addImage()`, відновлення початкового стану canvas. Експорт виконується для всіх доступних діаграм (ризики, фактори, розподіли, кореляції, історія) та вставляється у PDF у логічному порядку.

**Вирівнювання діаграм** — діаграми вирівнюються на сторінці PDF через обчислення розмірів у міліметрах та автоматичне масштабування. Кожна діаграма має максимальну ширину (зазвичай 180 мм для сторінки A4 з відступами) та висоту (залежно від типу діаграми), обчислюється коефіцієнт масштабування для вміщення на сторінку з збереженням пропорцій, діаграми центруються горизонтально через обчислення позиції X, діаграми розміщуються вертикально з відступами між ними для читабельності. Якщо діаграма не вміщується на поточну сторінку, створюється нова сторінка через `doc.addPage()`.

**Оптимізація якості** — якість PDF оптимізується через кілька механізмів: висока роздільна здатність експорту canvas (зазвичай 2x або 3x від оригінального розміру для чіткості тексту та ліній), оптимізація розміру зображень (стиснення PNG через параметри якості, якщо підтримується), використання векторних шрифтів (DejaVuSans для кирилиці забезпечує чіткий текст на будь-якому масштабі), оптимізація кольорів (використання RGB для точного відтворення кольорів діаграм), мінімізація кількості сторінок (ефективне розміщення контенту для зменшення розміру файлу). Це забезпечує високу якість PDF при розумному розмірі файлу.

**Проблеми з кирилицею та використання DejaVuSans** — стандартні шрифти jsPDF не підтримують кирилицю, тому для генерації PDF з українським текстом використовуються спеціальні шрифти DejaVuSans. Шрифти завантажуються асинхронно з файлів `fonts/DejaVuSans.ttf` (звичайний) та `fonts/DejaVuSans-Bold.ttf` (жирний) при першій генерації PDF через функцію `ensurePdfFontInitialized()`. Шрифти конвертуються у base64 та додаються до документа через `doc.addFileToVFS()` та `doc.addFont()`. Після додавання шрифтів вони використовуються через `doc.setFont('DejaVuSans', 'normal')` або `doc.setFont('DejaVuSans', 'bold')` для коректного відображення українського тексту. Шрифти кешуються в пам'яті для швидкого доступу при подальших генераціях PDF.

### 8.7. Діаграми

Діаграми у фронтенді реалізовані через бібліотеку Chart.js, яка забезпечує інтерактивні, адаптивні та високоякісні графіки для візуалізації даних.

**Chart.js як головна бібліотека** — Chart.js версії 4.4.6 використовується як основна бібліотека для побудови діаграм через кілька переваг: простота використання — інтуїтивний API для створення різних типів діаграм, висока якість — векторний рендеринг через canvas забезпечує чіткість на будь-якому масштабі, інтерактивність — підтримка tooltip-ів, легенд, масштабування та інших інтерактивних елементів, адаптивність — автоматична адаптація до розміру контейнера, анімації — плавні анімації появи та оновлення діаграм, експорт — можливість експорту у зображення через `toDataURL()`, підтримка тем — можливість налаштування кольорів та стилів для світлої/темної теми. Бібліотека завантажується з CDN через тег `<script>` у HTML та доступна глобально через `window.Chart`.

**Архітектура файлів графіків** — діаграми не мають окремих файлів, а реалізовані через функції у `app.js`, які створюють та оновлюють інстанси Chart.js. Функції включають `upsertDashboardChart()` для створення або оновлення діаграми, `exportChartsToPDF()` для експорту діаграм у PDF, `initializeInsights()` для ініціалізації всіх діаграм на сторінці діаграм, специфічні функції для кожного типу діаграми (наприклад, `renderRiskCharts()` для діаграм ризиків, `renderFactorChart()` для діаграми факторів). Всі інстанси Chart.js зберігаються у об'єкті `dashboardCharts` з ключами, що відповідають ID canvas-елементів, для швидкого доступу та управління.

**Як будуються та оновлюються графіки** — побудова графіків виконується через функцію `upsertDashboardChart()`, яка приймає ID canvas-елемента, тип діаграми, дані та опції конфігурації. Функція перевіряє, чи існує вже інстанс Chart.js для даного canvas (через `dashboardCharts[chartId]`), якщо так — оновлює дані через `chart.data = newData` та `chart.update()`, якщо ні — створює новий інстанс через `new Chart(canvas, config)`. Оновлення виконується автоматично при зміні даних (нові прогнози, оновлення історії, зміна фільтрів) через виклик `upsertDashboardChart()` з новими даними. Chart.js автоматично анімує зміни даних для плавності оновлення.

**Як експортуються в PDF** — експорт діаграм у PDF виконується через функцію `exportChartsToPDF()`, яка обходить всі діаграми на сторінці, експортує їх у PNG через `chart.toBase64Image()` або `canvas.toDataURL('image/png')` та вставляє у PDF через `doc.addImage()`. Процес включає тимчасове показування прихованих canvas (якщо діаграми на неактивній сторінці), збереження початкового стану для відновлення, експорт з високою роздільною здатністю (2x або 3x для чіткості), масштабування для вміщення на сторінку A4, вставку у PDF з правильним вирівнюванням, відновлення початкового стану canvas. Діаграми експортуються у логічному порядку (ризики, фактори, розподіли, кореляції, історія) та розміщуються на окремих сторінках або разом залежно від розміру.

**Особливості Canvas** — діаграми рендеряться на canvas-елементах, які мають кілька особливостей: роздільна здатність — canvas має фіксовану роздільну здатність, яка визначається атрибутами `width` та `height` (не CSS-розмірами), масштабування — CSS-розміри можуть масштабувати canvas, але для експорту важлива оригінальна роздільна здатність, прозорість — canvas підтримує прозорість через альфа-канал, що дозволяє створювати накладки та ефекти, продуктивність — canvas забезпечує швидкий рендеринг навіть для складних діаграм з багатьма точками даних, доступність — canvas не підтримує нативну доступність, тому важливо додавати альтернативний текст через атрибут `aria-label` або прихований текст.

**Проблеми з рендерингом і їх вирішення** — при роботі з діаграмами виникають кілька проблем та їх рішення: приховані canvas не експортуються — рішення: тимчасово показуємо canvas перед експортом через зміну display, visibility та hidden, низька якість експорту — рішення: збільшуємо роздільну здатність canvas перед експортом через зміну атрибутів width та height, діаграми не оновлюються при зміні розміру вікна — рішення: додаємо обробник події `resize`, який викликає `chart.resize()` для всіх діаграм, конфлікти кольорів з темою — рішення: оновлюємо кольори діаграм при зміні теми через `chart.options.plugins.legend.labels.color` та інші опції, пам'ять не звільняється при видаленні діаграм — рішення: викликаємо `chart.destroy()` перед видаленням інстансу для коректного звільнення пам'яті.

### 8.8. Системні сторінки

Системні сторінки забезпечують моніторинг стану всіх компонентів системи та відображення детальної інформації про їх роботу.

**`/api-status`** — це головна сторінка моніторингу системи, яка відображає стан API, бази даних та Ollama сервера. Сторінка включає індикатори стану для кожного компонента (онлайн/офлайн через кольорові індикатори), графіки часу відгуку для відстеження продуктивності, детальну статистику (кількість запитів, латентність, помилки), кнопки оновлення статусу для ручного оновлення даних. Сторінка оновлюється автоматично кожні 10 секунд через періодичні запити до ендпоінтів `/health`, `/system/database/stats` та `/assistant/health`. Статуси зберігаються в історії для побудови графіків трендів та аналізу продуктивності.

**`/api-status/history`** — це сторінка історії статусів системи, яка відображає хронологічну історію змін статусів компонентів. Сторінка включає таблицю або список записів з timestamp, статусом кожного компонента (API, БД, Ollama), латентністю запитів, помилками (якщо були) та деталями. Історія дозволяє відстежувати зміни стану системи у часі, виявляти проблеми та аналізувати тренди продуктивності. Історія може фільтруватися за компонентом, діапазоном дат або типом події (онлайн/офлайн/помилка).

**Анімації статусів** — індикатори стану мають анімації для візуального відображення змін: пульсація для онлайн-статусу (зелений індикатор пульсує для показу активності), обертання для очікування (spinner обертається під час перевірки статусу), fade in/out для зміни статусу (плавна зміна кольору при переході між станами), slide in для нових записів історії (нові записи з'являються з анімацією slide in зверху). Анімації забезпечують плавність інтерфейсу та привертають увагу до важливих змін стану.

**Індикатори живучості системи** — індикатори живучості відображають поточний стан компонентів через кольорові точки або badges: зелений для онлайн (компонент працює нормально), червоний для офлайн (компонент недоступний), жовтий для попередження (компонент працює, але з обмеженнями), сірий для невідомого стану (статус не визначено). Індикатори також можуть відображати числові значення (латентність у мілісекундах, кількість помилок) для детальної інформації. Індикатори оновлюються в реальному часі при зміні статусів та зберігають історію для аналізу.

**Концепція вкладок** — сторінка `/api-status` може використовувати вкладки для перемикання між різними компонентами системи (API, БД, Ollama) або різними типами інформації (поточний стан, історія, статистика). Вкладки реалізовані через HTML-структуру з кнопками перемикання та контейнерами контенту, які показуються/ховаються через CSS-класи. Вкладки мають активний стан (виділення поточної вкладки), плавні переходи між вкладками та збереження вибраної вкладки в LocalStorage для відновлення при наступному відвідуванні.

**Статусо-моніторинг Ollama** — моніторинг Ollama включає перевірку доступності локального Ollama сервера через ендпоінт `/assistant/health`, вимірювання латентності запитів (час відгуку у мілісекундах), відображення статусу моделі (яка модель завантажена, чи доступна), відображення помилок (якщо Ollama недоступна, показується детальна інформація про помилку). Моніторинг виконується періодично (кожні 10 секунд) та при ручному оновленні через кнопку. Статус Ollama критично важливий для роботи AI-асистента, тому індикатор має помітне розміщення та детальну інформацію про помилки.

**Статус Бази Даних** — моніторинг бази даних включає перевірку доступності через ендпоінт `/system/database/stats`, відображення статистики (кількість користувачів, прогнозів, чатів, повідомлень), відображення розміру БД (у байтах або мегабайтах), відображення активності за останні 7 днів (кількість нових записів, остання активність). Статус БД важливий для оцінки здоров'я системи та планування масштабування. Помилки підключення до БД відображаються як критичні та вимагають негайної уваги.

**Графік навантаження системи** — графіки навантаження відображають зміну продуктивності системи у часі через лінійні діаграми Chart.js. Графіки включають латентність API (час відгуку на запити), латентність Ollama (час генерації відповідей), кількість активних користувачів, кількість запитів за одиницю часу, розмір бази даних у часі. Графіки будуються на основі історії статусів, яка зберігається в `apiStatusHistory` та `ollamaStatusHistory`, та оновлюються автоматично при додаванні нових записів. Графіки дозволяють виявляти тренди, аномалії та проблеми продуктивності.

### 8.9. Реалізація AI-асистента (інтерфейсна частина)

Інтерфейс AI-асистента реалізований як чат-інтерфейс, який інтегрується з локальним Ollama сервером через API для генерації персоналізованих рекомендацій щодо здоров'я.

**Інтерфейс чату** — інтерфейс чату включає область повідомлень з історією діалогу, поле введення для повідомлень користувача, кнопку відправки та індикатор "Асистент думає..." під час генерації відповіді. Повідомлення відображаються у вигляді карток з різними стилями для повідомлень користувача (вирівняні праворуч, світлий фон) та асистента (вирівняні ліворуч, темніший фон), включають аватари (іконки для користувача та асистента), timestamps для кожного повідомлення та форматування тексту (підтримка переносів рядків, посилань). Інтерфейс має плавну анімацію появи нових повідомлень (fade in + slide) та автоматичну прокрутку до останнього повідомлення при додаванні нового.

**Взаємодія з бекендом** — взаємодія з бекендом виконується через ендпоінт `/assistant/chat`, який приймає повідомлення користувача, опційний `prediction_id` для контексту конкретного прогнозу та мову (`uk` або `en`). Фронтенд відправляє POST-запит з JSON-тілом, отримує відповідь асистента та відображає її в чаті. Всі повідомлення зберігаються в історії через ендпоінт `/assistant/history`, який повертає всі попередні повідомлення для відображення при завантаженні сторінки. Історія завантажується автоматично при активації сторінки асистента та оновлюється після кожного нового повідомлення.

**Логіка повідомлень** — логіка повідомлень включає кілька аспектів: відправка повідомлень — при натисканні кнопки відправки або Enter у полі введення повідомлення валідується (перевірка на порожність, максимальна довжина), відображається в чаті як повідомлення користувача, відправляється на бекенд через API, відображається індикатор "Перевірка..." під час очікування відповіді; отримання відповіді — після отримання відповіді від API індикатор "Перевірка..." замінюється на відповідь асистента, відповідь відображається в чаті як повідомлення асистента, історія оновлюється для відображення нового повідомлення; обробка помилок — при помилці підключення до Ollama або інших помилках відображається повідомлення про помилку в чаті з деталями та рекомендаціями для користувача.

**Збереження історії** — історія повідомлень зберігається в базі даних через бекенд та завантажується на фронтенді при активації сторінки асистента. Історія включає всі попередні повідомлення користувача та асистента, зберігає порядок хронологічно, включає timestamps для кожного повідомлення та може бути пов'язана з конкретним прогнозом через `prediction_id`. Історія відображається в чаті у хронологічному порядку з можливістю прокрутки до початку діалогу. Історія також може бути очищена через ендпоінт `/assistant/history` (DELETE) для початку нового діалогу.

**Автоматичні відповіді** — автоматичні відповіді генеруються Ollama на основі контексту про стан здоров'я користувача, який формується на бекенді. Контекст включає інформацію про останній прогноз (цільова змінна, ймовірність, категорія ризику, топ фактори), вхідні параметри користувача (вік, стать, ІМТ, артеріальний тиск, лабораторні показники) та системний промпт з інструкціями для асистента (не ставити діагнози, не призначати лікування, надавати загальні рекомендації). Відповіді генеруються українською або англійською мовою залежно від параметра `language` у запиті та включають персоналізовані рекомендації на основі контексту.

**Dynamically resizing textarea** — поле введення для повідомлень реалізовано як textarea, яка автоматично змінює висоту залежно від вмісту. При введенні тексту textarea розширюється вертикально для вміщення всього тексту без необхідності прокрутки, має максимальну висоту (зазвичай 4-5 рядків), після чого з'являється вертикальна прокрутка. Зміна розміру виконується через JavaScript, який встановлює `textarea.style.height = 'auto'` для скидання висоти, потім `textarea.style.height = textarea.scrollHeight + 'px'` для встановлення нової висоти на основі вмісту. Це забезпечує зручне введення довгих повідомлень без необхідності ручного змінення розміру поля.

