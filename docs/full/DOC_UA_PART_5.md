# Частина 5: Візуальні звіти, системні сторінки, чат, UX, безпека та висновки

## 17. Візуальні звіти та PDF-генерація

### 17.1. Концепція PDF-звіту

PDF-звіти у проєкті HealthRisk.AI слугують офіційним документом, який користувачі можуть зберігати, друкувати та використовувати для консультацій з лікарями або аналізу своїх ризиків здоров'я.

**Навіщо PDF** — PDF-звіти необхідні для кількох причин: переносимість — PDF-файли можна легко передавати, зберігати та відкривати на будь-яких пристроях без необхідності доступу до вебінтерфейсу, офіційність — PDF-формат визнається як офіційний документ, який можна використовувати для медичних консультацій, зручність — користувачі можуть друкувати звіти, зберігати їх у папках, ділитися з лікарями, аналізувати зміни ризиків у часі, повнота — PDF-звіти містять всю необхідну інформацію про прогноз (ймовірність, категорію ризику, топ фактори, діаграми, рекомендації) в структурованому вигляді, незалежність — звіти не залежать від доступності вебінтерфейсу, користувачі можуть переглядати їх навіть без інтернету. PDF-звіти є важливою частиною користувацького досвіду, оскільки надають користувачам конкретний результат їх взаємодії з системою.

**Які дані включає** — PDF-звіт містить комплексну інформацію про прогноз ризику здоров'я: титульна сторінка з назвою проєкту, датою генерації, інформацією про користувача (якщо автентифікований), результати прогнозування (цільова змінна — діабет або ожиріння, ймовірність ризику у відсотках, категорія ризику — низький, середній або високий), топ фактори впливу (список найважливіших факторів з їх впливом у відсотках, наприклад, ІМТ — 35%, глюкоза — 28%, вік — 15%), діаграми ризиків (візуалізація ймовірності, розподілу факторів, кореляцій, історії прогнозів), тлумачення результатів (пояснення що означає категорія ризику, як інтерпретувати ймовірність, що робити далі), метадані моделі (назва використаної ML-моделі, версія, дата навчання, метрики якості), технічні деталі (вхідні параметри прогнозу, час генерації, версія системи). Всі дані структуровані та відформатовані для легкого читання та розуміння.

**Як користувач взаємодіє з кнопками форматів** — користувачі можуть експортувати звіти у різних форматах через кнопки на сторінці історії прогнозів або на сторінці результатів: кнопка "PDF" — генерує PDF-звіт з усіма діаграмами, текстом та форматуванням, кнопка "Excel" — експортує дані у формат Excel для аналізу в таблицях, кнопка "CSV" — експортує дані у формат CSV для імпорту в інші системи, кнопка "JSON" — експортує сирі дані у формат JSON для програмної обробки. Кнопки розташовані поруч з кожним прогнозом у історії та на сторінці результатів. При натисканні кнопки PDF відображається overlay "Формуємо PDF-звіт..." з індикатором завантаження, який блокує інтерфейс під час генерації. Після завершення генерації PDF автоматично завантажується через браузер. Інші формати (Excel, CSV, JSON) генеруються миттєво без overlay, оскільки не потребують складних операцій.

### 17.2. Структура PDF

PDF-звіт має чітку структуру з послідовним розташуванням інформації для легкого читання та розуміння.

**Титульна частина** — перша сторінка PDF містить титульну інформацію: назва проєкту "HealthRisk.AI" великим шрифтом, підзаголовок "Система оцінки ризиків здоров'я" або "Health Risk Assessment System", дата генерації звіту у форматі "DD.MM.YYYY HH:MM", інформація про користувача (якщо автентифікований) — ім'я, email, дата народження, стать, логотип або іконка проєкту (якщо є), версія системи або метадані про звіт. Титульна сторінка оформлена у професійному стилі з використанням корпоративних кольорів та шрифтів. Вона слугує обкладинкою звіту та надає перше враження про якість документа.

**Ризик** — розділ з результатами прогнозування містить: цільову змінну (діабет або ожиріння) великим шрифтом, ймовірність ризику у відсотках (наприклад, "Ймовірність: 67%") з візуальним індикатором (прогрес-бар або кругова діаграма), категорію ризику (низький, середній, високий) з кольоровим кодуванням (зелений, жовтий, червоний), коротке пояснення що означає ця категорія, рекомендації щодо наступних кроків (консультація з лікарем, зміна способу життя, моніторинг показників). Розділ оформлений для швидкого розуміння основного результату без необхідності читати весь звіт.

**Фактори** — розділ з топ факторами впливу містить: список найважливіших факторів (зазвичай топ-5) з їх впливом у відсотках, візуалізацію факторів у вигляді горизонтальних барів або кругової діаграми, опис кожного фактора (що він означає, як впливає на ризик), рекомендації щодо зменшення впливу кожного фактора. Фактори відсортовані за впливом (від найбільшого до найменшого) для акцентування уваги на найважливіших. Кожен фактор має назву (наприклад, "Індекс маси тіла (ІМТ)"), значення (наприклад, "32.5"), вплив у відсотках (наприклад, "35%") та пояснення.

**Тлумачення** — розділ з тлумаченням результатів містить: детальне пояснення що означає категорія ризику (низький, середній, високий), як інтерпретувати ймовірність (що означає 67% ризику), що робити далі (консультація з лікарем, зміна способу життя, моніторинг показників), застереження (система не ставить діагнозів, не призначає лікування, надає тільки оцінку ризику), посилання на додаткові ресурси (якщо є). Тлумачення написане зрозумілою мовою без медичних термінів для забезпечення доступності для всіх користувачів.

**Моделі** — розділ з метаданими моделі містить: назву використаної ML-моделі (наприклад, "Logistic Regression", "Random Forest"), версію моделі або дату навчання, метрики якості моделі (ROC-AUC, Accuracy, Precision, Recall), інформацію про калібрування (чи використовується калібрована версія), опис моделі (як вона працює, які дані використовує). Метадані надають прозорість системі та дозволяють користувачам зрозуміти, як було отримано результат. Це важливо для довіри до системи та для медичних консультацій.

**Дата/метадані** — остання сторінка PDF містить технічні метадані: дата та час генерації звіту, версія системи або API, вхідні параметри прогнозу (вік, стать, ІМТ, артеріальний тиск, глюкоза, холестерин), унікальний ідентифікатор звіту (якщо є), інформація про авторські права або ліцензію, застереження про використання (система не замінює консультацію з лікарем). Метадані корисні для відстеження змін у часі, діагностики проблем та забезпечення прозорості системи.

### 17.3. Генерація PDF

Генерація PDF виконується повністю на фронтенді через бібліотеку jsPDF, що забезпечує швидкість, безпеку та незалежність від сервера.

**Чому jsPDF** — jsPDF обрана як основна бібліотека для генерації PDF через кілька переваг: клієнтська генерація — PDF генерується на клієнті, що зменшує навантаження на сервер та забезпечує швидкість, безпека — дані користувачів не передаються на сервер для генерації, всі дані залишаються локально у браузері, простота використання — інтуїтивний API для створення PDF-документів з текстом, зображеннями, таблицями, підтримка форматування — можливість налаштування шрифтів, кольорів, розмірів, відступів, підтримка багатосторінковості — автоматичне створення нових сторінок при переповненні, підтримка зображень — можливість вставляти зображення (діаграми) у PDF, широке використання — популярна бібліотека з активною підтримкою та документацією. jsPDF завантажується з CDN через тег `<script>` у HTML та доступна глобально через `window.jsPDF` або `window.jspdf.jsPDF`.

**Шрифти + проблема кирилиці** — стандартні шрифти jsPDF не підтримують кирилицю, тому для генерації PDF з українським текстом використовуються спеціальні шрифти. Проблема кирилиці виникає через те, що jsPDF за замовчуванням використовує шрифти, які підтримують тільки латиницю. При спробі використати кирилицю зі стандартними шрифтами текст відображається як порожні квадрати або некоректні символи. Це критична проблема для української локалізації, оскільки всі тексти в PDF повинні бути українською мовою.

**Рішення з DejaVuSans** — для вирішення проблеми кирилиці використовуються шрифти DejaVuSans, які підтримують кирилицю та багато інших мов. DejaVuSans — це вільний шрифт з повною підтримкою Unicode, включаючи кирилицю, грецьку, арабську та інші скрипти. Шрифти зберігаються у файлах `fonts/DejaVuSans.ttf` (звичайний) та `fonts/DejaVuSans-Bold.ttf` (жирний) у директорії фронтенду та завантажуються асинхронно при першій генерації PDF.

**Завантаження локального шрифту** — завантаження шрифтів виконується через функцію `ensurePdfFontInitialized()`, яка перевіряє, чи шрифти вже завантажені, та завантажує їх при потребі. Процес включає: завантаження TTF-файлів через `fetch()` з локальної директорії, конвертацію шрифтів у base64 для включення в PDF, додавання шрифтів до Virtual File System (VFS) jsPDF через `doc.addFileToVFS()`, реєстрацію шрифтів через `doc.addFont()` з вказанням назви та стилю (normal, bold), кешування завантажених шрифтів у пам'яті для швидкого доступу при подальших генераціях. Шрифти завантажуються один раз при першій генерації PDF та використовуються для всіх наступних генерацій без повторного завантаження.

**Верстка PDF у коді** — верстка PDF виконується програмно через API jsPDF: створення документа через `new jsPDF()` з параметрами формату (A4: 210x297 мм), встановлення шрифту через `doc.setFont('DejaVuSans', 'normal')` або `doc.setFont('DejaVuSans', 'bold')`, додавання тексту через `doc.text(text, x, y)` з координатами у міліметрах, встановлення розміру шрифту через `doc.setFontSize(size)`, встановлення кольору тексту через `doc.setTextColor(r, g, b)`, додавання зображень через `doc.addImage(imageData, format, x, y, width, height)`, створення нових сторінок через `doc.addPage()` при переповненні, збереження PDF через `doc.save(filename)`. Верстка виконується послідовно з обчисленням позицій елементів, відступів та розмірів для оптимального розміщення контенту на сторінці.

**Адаптивність для різних даних** — PDF-звіт адаптується до різних обсягів даних через: автоматичне створення нових сторінок при переповненні контенту, обчислення висоти тексту для визначення необхідності нової сторінки, масштабування діаграм для вміщення на сторінку з збереженням пропорцій, обрізання довгих текстів з додаванням многоточия або перенесення на нову сторінку, динамічне розташування елементів залежно від наявності даних (якщо немає діаграм, текст займає більше місця). Адаптивність забезпечує, що PDF-звіт виглядає професійно незалежно від обсягу даних.

### 17.4. Генерація графіків у PDF

Діаграми з Chart.js конвертуються у зображення та вставляються у PDF для візуалізації даних.

**Конвертація Chart.js → PNG** — конвертація діаграм Chart.js у PNG-зображення виконується через метод `toBase64Image()` або `canvas.toDataURL('image/png')`. Процес включає: отримання canvas-елемента з Chart.js інстансу через `chartInstance.canvas`, виклик методу `toBase64Image()` для експорту діаграми у base64-кодоване PNG-зображення, встановлення високої роздільної здатності для забезпечення якості (наприклад, scale 2x або 3x), обробка помилок (якщо canvas порожній або діаграма не відрендерена), збереження зображення у форматі data URL для передачі до jsPDF. Конвертація виконується для всіх діаграм на сторінці перед генерацією PDF.

**Проблема blank canvas** — проблема порожнього canvas виникає, коли діаграма не відрендерена або прихована під час експорту. Canvas може бути порожнім через: діаграма не ініціалізована, діаграма прихована через CSS (`display: none` або `visibility: hidden`), діаграма не оновлена після зміни даних, canvas не має розмірів (width або height = 0), діаграма ще не завершила анімацію появи. Порожній canvas призводить до того, що в PDF вставляється порожнє зображення або зображення з помилкою.

**Рішення через re-render** — для вирішення проблеми порожнього canvas виконується re-render діаграми перед експортом: тимчасове показування прихованої діаграми через зміну CSS (`display: block`, `visibility: visible`), оновлення діаграми через `chartInstance.update()` для перерисовки, очікування завершення рендерингу через `requestAnimationFrame()` або `setTimeout()`, експорт canvas після переконання, що він заповнений, відновлення оригінального стану діаграми (приховування, якщо було приховано). Re-render забезпечує, що canvas містить актуальні дані перед експортом.

**Оптимізація якості** — якість зображень діаграм оптимізується через: встановлення високої роздільної здатності при експорті (scale 2x або 3x для чіткості), збереження пропорцій діаграми при масштабуванні для PDF, використання оптимальних параметрів якості для `toDataURL()` (якість 1.0 для максимальної якості), обмеження розміру зображення для балансу між якістю та розміром файлу, використання PNG замість JPEG для збереження чіткості текстів та ліній. Оптимізація забезпечує, що діаграми виглядають чітко у PDF без розмиття або пікселізації.

**Стиснення → збереження читабельності** — баланс між стисненням та читабельністю досягається через: використання оптимального масштабу (2x для балансу між якістю та розміром), обмеження кількості діаграм на сторінку (4 діаграми максимум), масштабування діаграм для вміщення на сторінку без втрати читабельності, використання PNG замість JPEG для збереження чіткості, оптимізація розміру canvas перед експортом (не занадто великий, не занадто малий). Стиснення не виконується агресивно, оскільки читабельність діаграм важливіша за розмір файлу.

### 17.5. Макет багатосторінковості

PDF-звіт може містити кілька сторінок для вміщення всієї інформації та діаграм.

**4 графіки на сторінку** — оптимальна кількість діаграм на одну сторінку A4 — 4 діаграми (2x2 сітка) для забезпечення читабельності та зручності перегляду. Розташування включає: обчислення розмірів діаграм для вміщення 4 діаграм на сторінку з відступами, розташування діаграм у сітці 2x2 з рівномірними відступами, додавання заголовків до кожної діаграми для ідентифікації, збереження пропорцій діаграм при масштабуванні. Якщо діаграм більше 4, створюються нові сторінки з наступними 4 діаграмами.

**Центрування** — діаграми та текст центруються на сторінці для професійного вигляду: обчислення центру сторінки (ширина A4: 210 мм, центр: 105 мм), розташування елементів відносно центру, вирівнювання тексту по центру через `doc.text()` з параметром `align: 'center'`, центрування діаграм у сітці 2x2. Центрування забезпечує збалансований вигляд сторінки та легкість читання.

**Контроль пропорцій** — пропорції діаграм зберігаються при масштабуванні для вміщення на сторінку: обчислення оригінальних пропорцій діаграми (width/height), обчислення максимального розміру для вміщення на сторінку з відступами, масштабування з збереженням пропорцій (якщо оригінальна ширина більша за висоту, масштабується по ширині, і навпаки), обрізання діаграм, якщо необхідно, для вміщення на сторінку. Контроль пропорцій забезпечує, що діаграми не виглядають спотвореними у PDF.

**Генерація сторінок послідовно** — сторінки PDF генеруються послідовно для забезпечення коректного порядку та структури: створення першої сторінки (титульна), додавання контенту на першу сторінку, створення нової сторінки через `doc.addPage()` при переповненні, додавання контенту на нову сторінку, повторення процесу для всіх сторінок. Послідовна генерація забезпечує, що контент розташований у правильному порядку та не перетинається між сторінками.

## 18. Системні підсторінки

Системні підсторінки надають інформацію про стан системи, історію роботи та загальну інформацію про проєкт.

### 18.1. /api-status

Сторінка `/api-status` відображає поточний стан всіх компонентів системи для моніторингу та діагностики.

**Перевірка API** — перевірка стану API виконується через ендпоінт `/health`, який повертає інформацію про доступність API, версію, кількість маршрутів та timestamp. Фронтенд робить періодичні запити (кожні 10 секунд) до цього ендпоінта та відображає статус через індикатор (зелений для онлайн, червоний для офлайн). Статус включає: доступність API (онлайн/офлайн), версія API (якщо є), кількість маршрутів, час останньої перевірки, латентність запиту (час відгуку в мілісекундах). Інформація відображається у вкладці "API" на сторінці `/api-status`.

**Перевірка Ollama** — перевірка стану Ollama виконується через ендпоінт `/assistant/health`, який робить тестовий запит до локального Ollama сервера та вимірює латентність. Фронтенд робить періодичні запити (кожні 10 секунд) до цього ендпоінта та відображає статус через індикатор. Статус включає: доступність Ollama (онлайн/офлайн/таймаут/помилка), латентність запиту (час відгуку в мілісекундах), наявність моделі (якщо перевіряється), текст помилки (якщо є), час останньої перевірки. Інформація відображається у вкладці "Ollama" на сторінці `/api-status`.

**Індикатори доступності** — індикатори доступності відображаються через кольорові індикатори для швидкого розуміння стану: зелений індикатор — компонент онлайн та працює коректно, червоний індикатор — компонент офлайн або не відповідає, жовтий індикатор — компонент працює, але з затримками або помилками, сірий індикатор — статус невідомий або не перевірено. Індикатори оновлюються автоматично при кожній перевірці статусу та можуть бути оновлені вручну через кнопку "Оновити".

**Анімація «Перевірка…»** — під час перевірки статусу відображається анімація "Перевірка..." з трьома крапками, які анімуються послідовно для індикації процесу перевірки. Анімація виконується через CSS анімації або JavaScript та зникає після отримання відповіді від сервера. Анімація забезпечує, що користувач бачить, що система працює та обробляє запит.

**Табовий інтерфейс** — сторінка `/api-status` використовує табовий інтерфейс для перемикання між різними компонентами системи: вкладка "API" — статус API, версія, маршрути, вкладка "База даних" — статистика БД, кількість записів, розмір, активність, вкладка "Ollama" — статус Ollama, латентність, помилки. Табовий інтерфейс реалізований через HTML-структуру з CSS для стилізації та JavaScript для перемикання вкладок. Активна вкладка виділяється кольором або підкресленням для візуального розрізнення.

### 18.2. /api-status/history

Сторінка `/api-status/history` відображає історію статусів компонентів системи для аналізу трендів та діагностики проблем.

**Лог навантаження** — лог навантаження зберігає історію запитів до API, БД та Ollama для аналізу навантаження системи. Лог включає: час кожного запиту, латентність відповіді, статус (успіх/помилка), тип запиту (API, БД, Ollama), деталі помилок (якщо є). Лог зберігається у пам'яті на фронтенді (масив `apiStatusHistory`, `ollamaStatusHistory`) та може бути збережений у БД для довгострокового аналізу. Лог дозволяє виявити патерни навантаження, піки активності та проблеми з продуктивністю.

**Час відгуку** — час відгуку вимірюється для кожного запиту до компонентів системи та відображається у вигляді графіка для візуалізації трендів. Графік показує: латентність API у мілісекундах, латентність БД у мілісекундах, латентність Ollama у мілісекундах, тренди збільшення або зменшення латентності, піки латентності (можуть вказувати на проблеми). Графік оновлюється автоматично при кожній перевірці статусу та дозволяє виявити проблеми з продуктивністю.

**Ідея «uptime графіка»** — uptime графік відображає відсоток часу, коли компонент був онлайн, за певний період (наприклад, останні 24 години, тиждень, місяць). Графік показує: періоди онлайн (зелені смуги), періоди офлайн (червоні смуги), загальний uptime у відсотках, найдовші періоди офлайн, найкоротші періоди офлайн. Uptime графік дозволяє оцінити надійність системи та виявити проблеми з доступністю.

**Як збирається статистика** — статистика збирається через періодичні запити (кожні 10 секунд) до ендпоінтів статусів та збереження результатів у масивах на фронтенді. Статистика включає: час кожного запиту, латентність відповіді, статус компонента, помилки (якщо є). Статистика зберігається у пам'яті та може бути експортована у JSON для подальшого аналізу. Для довгострокового зберігання статистика може бути збережена у БД через окрему таблицю для логів статусів.

### 18.3. /about

Сторінка `/about` надає загальну інформацію про проєкт, його мету, історію та технології.

**Для чого сторінка** — сторінка `/about` слугує для: інформування користувачів про проєкт, його мету та призначення, надання інформації про технології, які використовуються, демонстрації професійного підходу до розробки, надання контактної інформації або посилань на додаткові ресурси, пояснення як працює система, які дані використовуються, як інтерпретувати результати. Сторінка допомагає користувачам зрозуміти систему та довіряти їй.

**Структура** — сторінка `/about` має структурований вигляд з розділами: заголовок "Про проєкт" або "About", опис проєкту (що це, навіщо, для кого), історія проєкту (коли створено, хто розробляв, версії), технології (які технології використовуються, чому вони обрані), джерела даних (NHANES, Kaggle, як дані використовуються), команда або автор (якщо є), контакти або посилання (якщо є), ліцензія або авторські права. Структура забезпечує легке читання та розуміння інформації.

**Історія проєкту** — розділ з історією проєкту містить: дату створення проєкту, мету проєкту (магістерська робота, дослідження, комерційний проєкт), етапи розробки (ETL, EDA, ML, API, Frontend), версії проєкту (якщо є), досягнення або нагороди (якщо є), майбутні плани розвитку. Історія допомагає користувачам зрозуміти контекст проєкту та його еволюцію.

**Компонування інформації** — інформація на сторінці `/about` компонується для легкого читання: використання заголовків та підзаголовків для структури, розділення інформації на блоки з візуальним розділенням, використання списків для переліку технологій або функцій, використання іконок або зображень для візуалізації, адаптивний дизайн для різних розмірів екранів. Компонування забезпечує професійний вигляд сторінки та легкість читання.

## 19. Чат та AI-асистент

AI-асистент надає персоналізовані рекомендації щодо здоров'я на основі результатів прогнозування користувача.

### 19.1. Призначення AI-асистента

AI-асистент слугує допоміжним інструментом для користувачів у розумінні результатів прогнозування та отриманні рекомендацій.

**Для чого він у системі** — AI-асистент виконує кілька функцій: пояснення результатів прогнозування зрозумілою мовою, надання рекомендацій щодо зменшення ризиків, відповіді на питання користувачів про їх стан здоров'я, надання контексту про фактори ризику та їх вплив, допомога у інтерпретації технічних термінів та метрик. Асистент не ставить діагнозів, не призначає лікування, а надає тільки загальні рекомендації на основі результатів прогнозування.

**Як допомагає користувачу** — асистент допомагає користувачу через: пояснення що означає категорія ризику (низький, середній, високий), інтерпретацію ймовірності ризику (що означає 67% ризику), рекомендації щодо наступних кроків (консультація з лікарем, зміна способу життя), пояснення факторів ризику та їх впливу, відповіді на питання про стан здоров'я в контексті прогнозу. Асистент працює як персональний консультант, який допомагає користувачу зрозуміти результати та прийняти рішення.

**Типи відповідей** — асистент надає різні типи відповідей: інформаційні відповіді (пояснення термінів, метрик, факторів), рекомендаційні відповіді (що робити для зменшення ризиків), пояснювальні відповіді (як інтерпретувати результати), застережувальні відповіді (нагадування про необхідність консультації з лікарем), підтримуючі відповіді (мотивація для зміни способу життя). Всі відповіді написані зрозумілою мовою без медичних термінів для забезпечення доступності.

### 19.2. Архітектура чату

Архітектура чату організована через розділення на фронтенд (UI) та бекенд (логіка обробки).

**Дві частини: фронт і бек** — чат складається з двох частин: фронтенд відповідає за відображення інтерфейсу чату, обробку введення користувача, відображення повідомлень, управління скролом, анімації, бекенд відповідає за обробку повідомлень, формування контексту, виклик Ollama, збереження історії, валідацію даних. Фронтенд та бекенд взаємодіють через REST API для передачі повідомлень та отримання відповідей.

**Потоки повідомлень** — потік повідомлень організований як послідовний процес: користувач вводить повідомлення у текстове поле, натискає кнопку "Відправити", фронтенд валідує повідомлення (не порожнє, не занадто довге), фронтенд відправляє POST-запит до `/assistant/chat` з повідомленням та опційним `prediction_id`, бекенд зберігає повідомлення користувача в БД, бекенд формує контекст про стан здоров'я користувача, бекенд викликає Ollama для генерації відповіді, бекенд зберігає відповідь асистента в БД, бекенд повертає відповідь фронтенду, фронтенд відображає відповідь у чаті. Потік забезпечує коректну обробку повідомлень та збереження історії.

**Обробка JSON-повідомлень** — повідомлення передаються у форматі JSON через REST API: запит містить поля `message` (текст повідомлення), `prediction_id` (опційний, для контексту конкретного прогнозу), `language` (uk або en), відповідь містить поля `response` (текст відповіді асистента), `timestamp` (час відповіді), `context` (опційний, контекст, який використовувався). JSON забезпечує структурованість даних та легкість обробки на обох сторонах.

**Збереження історії в БД** — історія діалогів зберігається в таблиці `assistantmessage` для кожного користувача: кожне повідомлення користувача зберігається з `role: "user"`, кожна відповідь асистента зберігається з `role: "assistant"`, повідомлення зберігаються хронологічно з timestamps, повідомлення можуть бути пов'язані з конкретним прогнозом через `prediction_id` для контексту. Історія завантажується при активації сторінки асистента через ендпоінт `/assistant/history` та відображається на фронтенді для користувача.

### 19.3. Логіка AI-відповідей

Логіка формування відповідей AI-асистента організована через формування промптів, контексту та виклик Ollama.

**Формування prompt** — промпт формується через функцію `build_assistant_prompt()` у модулі `assistant_llm.py` та включає: системний промпт з інструкціями для асистента (асистент не ставить діагнозів, не призначає лікування, надає загальні рекомендації), контекст про стан здоров'я користувача (формується через `build_health_context()` на основі останнього прогнозу), запит користувача (текст повідомлення від користувача). Промпт формується як структурований текст з чіткими розділами для зрозумілості LLM.

**Контекст** — контекст про стан здоров'я користувача формується через функцію `build_health_context()` на основі останнього прогнозу з БД: отримання останнього прогнозу користувача через `get_latest_prediction()`, форматування контексту як текстового опису (цільова змінна, ймовірність, категорія ризику, топ фактори), додавання контексту до промпту для LLM. Контекст забезпечує, що асистент надає персоналізовані рекомендації на основі конкретних результатів користувача.

**Пам'ять** — пам'ять діалогу зберігається в таблиці `assistantmessage` для кожного користувача: всі попередні повідомлення користувача та асистента зберігаються хронологічно, історія може бути використана для покращення контексту майбутніх відповідей (хоча наразі контекст формується тільки на основі останнього прогнозу), історія завантажується при активації сторінки асистента та відображається на фронтенді. В майбутньому можна додати використання повної історії діалогів для покращення контексту та забезпечення послідовності розмови.

**Як Ollama обробляє запити** — Ollama обробляє запити через HTTP API: бекенд відправляє POST-запит до `http://localhost:11434/api/generate` з JSON payload (`model`, `prompt`, `stream: false`), Ollama обробляє промпт через LLM (наприклад, Llama3), генерує відповідь на основі промпту та контексту, повертає відповідь у форматі JSON з полем `response`, бекенд обробляє відповідь та зберігає її в БД. Ollama працює локально, що забезпечує приватність даних та швидкість відповідей.

### 19.4. Реалізація UI чату

UI чату реалізований для забезпечення зручної взаємодії користувача з AI-асистентом.

**Адаптивність** — UI чату адаптується до різних розмірів екранів: на десктопі чат займає всю доступну ширину з фіксованою висотою, на мобільних пристроях чат займає весь екран з адаптивними розмірами, повідомлення автоматично переносяться на новий рядок при переповненні, кнопка "Відправити" адаптується до розміру екрану, скрол адаптується до висоти екрану. Адаптивність забезпечує зручну взаємодію на всіх пристроях.

**Система scroll-to-bottom** — автоматичний скрол до останнього повідомлення реалізується через: виклик `scrollIntoView()` для останнього повідомлення при додаванні нового, використання `requestAnimationFrame()` для плавного скролу, збереження позиції скролу при оновленні повідомлень, можливість ручного скролу для перегляду старих повідомлень. Scroll-to-bottom забезпечує, що користувач завжди бачить останнє повідомлення без необхідності ручного скролу.

**Обмежувачі контексту** — обмежувачі контексту забезпечують, що промпт не перевищує обмеження LLM: обмеження довжини повідомлення користувача (наприклад, максимум 1000 символів), обмеження довжини контексту (наприклад, тільки останній прогноз, не вся історія), обрізання довгих текстів з додаванням многоточия, валідація вхідних даних перед відправкою. Обмежувачі забезпечують, що запити до Ollama не перевищують обмеження та обробляються коректно.

**Завантаження старих повідомлень** — завантаження старих повідомлень виконується через ендпоінт `/assistant/history`, який повертає всі повідомлення користувача, відсортовані за часом: завантаження історії при активації сторінки асистента, відображення повідомлень у хронологічному порядку, можливість прокрутки вгору для перегляду старих повідомлень, кешування історії для швидкого доступу. Завантаження забезпечує, що користувач бачить всю історію діалогу з асистентом.

## 20. Користувацький досвід (UX) та доступність

UX та доступність забезпечують зручну та інклюзивну взаємодію користувачів з системою.

### 20.1. UX принципи

UX принципи орієнтовані на простоту, зрозумілість та ефективність взаємодії.

**Проста логіка** — логіка системи організована для мінімізації складності: мінімальна кількість кроків для виконання задач (наприклад, прогноз за 3 кроки: введення даних, натискання кнопки, перегляд результатів), інтуїтивна навігація (зрозумілі назви сторінок, логічне розташування елементів), передбачувана поведінка (кнопки працюють так, як очікує користувач), мінімальна кількість рішень для користувача (система надає рекомендації, не вимагає складних виборів). Проста логіка забезпечує, що користувачі можуть використовувати систему без навчання.

**Мінімум кнопок** — інтерфейс містить тільки необхідні кнопки для мінімізації плутанини: основні дії (прогноз, історія, профіль) доступні через навігацію, додаткові дії (експорт, налаштування) доступні через контекстні меню або іконки, невикористовувані кнопки приховані, кнопки мають зрозумілі назви або іконки. Мінімум кнопок забезпечує чистий інтерфейс та легкість навігації.

**Доступний текст** — текст у системі написаний зрозумілою мовою: мінімум технічних термінів, пояснення складних концепцій простими словами, використання коротких речень, використання активного замість пасивного стану, використання конкретних замість абстрактних слів. Доступний текст забезпечує, що всі користувачі можуть зрозуміти інформацію без медичної освіти.

**Правильна ієрархія** — ієрархія інформації організована для акцентування важливих елементів: заголовки використовуються для структури (H1 для головного заголовка, H2 для розділів, H3 для підрозділів), важлива інформація виділяється розміром, кольором або жирним шрифтом, менш важлива інформація прихована за розгортанням або на окремих сторінках, логічний порядок елементів (зверху вниз, зліва направо). Правильна ієрархія забезпечує, що користувачі швидко знаходять потрібну інформацію.

### 20.2. Анімації

Анімації використовуються для покращення користувацького досвіду та візуальної привабливості.

**Доти** — анімації при дотику (hover, click) забезпечують візуальний зворотний зв'язок: зміна кольору кнопок при наведенні (hover effect), зміна розміру або тіні при натисканні (active effect), плавні переходи між станами (transition), анімації появи елементів (fade in, slide in). Анімації дотиків забезпечують, що користувач бачить реакцію системи на свої дії.

**Модалки** — анімації модальних вікон забезпечують плавне відкриття та закриття: fade in/out для overlay, slide down/up для модального вікна, scale in/out для акцентування, затримка для послідовного відображення елементів. Анімації модалок забезпечують професійний вигляд та плавність взаємодії.

**Прелоадер PDF** — прелоадер PDF відображається під час генерації PDF для інформування користувача: overlay з напівпрозорим фоном, індикатор завантаження (спінер або прогрес-бар), текст "Формуємо PDF-звіт...", анімація завантаження (обертання спінера, анімація крапок). Прелоадер забезпечує, що користувач бачить, що система працює та обробляє запит.

### 20.3. Accessibility

Доступність забезпечує, що система може бути використана людьми з обмеженими можливостями.

**Контрастність** — контрастність кольорів забезпечує читабельність тексту: мінімальний контраст 4.5:1 для звичайного тексту, мінімальний контраст 3:1 для великого тексту, використання темної теми для покращення контрасту, перевірка контрасту через інструменти (наприклад, WCAG Contrast Checker). Контрастність забезпечує, що текст читабельний для всіх користувачів.

**Альтернативні тексти** — альтернативні тексти для зображень забезпечують доступність для screen readers: атрибут `alt` для всіх зображень з описом змісту, атрибут `title` для додаткової інформації, опис діаграм у тексті для користувачів з обмеженим зором. Альтернативні тексти забезпечують, що користувачі з screen readers можуть зрозуміти зміст зображень.

**ARIA-атрибути** — ARIA-атрибути забезпечують доступність для screen readers: `aria-label` для опису елементів, `aria-labelledby` для зв'язку з заголовками, `aria-describedby` для додаткового опису, `aria-hidden` для приховування декоративних елементів, `role` для визначення ролі елементів. ARIA-атрибути забезпечують, що screen readers можуть коректно інтерпретувати інтерфейс.

## 21. Резервне копіювання та збереження даних

Резервне копіювання забезпечує збереження даних та можливість відновлення при втраті.

**Резервне копіювання БД** — резервне копіювання бази даних виконується через копіювання файлу `data/app.db` на окремий сервер або у хмарне сховище: регулярне копіювання (наприклад, щодня через cron job), збереження кількох версій backup (останні 7 днів, останні 4 тижні, останній місяць), шифрування backup для безпеки, перевірка цілісності backup перед збереженням. Резервне копіювання забезпечує, що дані можуть бути відновлені при втраті.

**Робота з файлами** — робота з файлами включає: збереження аватарів користувачів у директорії `data/avatars/`, збереження ML моделей у директорії `artifacts/models/`, збереження датасетів у директорії `datasets/`, збереження логів у директорії `logs/` (якщо є). Всі файли повинні бути включені у резервне копіювання для повного відновлення системи.

**Де зберігати data** — дані зберігаються у директорії `data/` у корені проєкту: `data/app.db` — база даних, `data/avatars/` — аватари користувачів, інші дані (якщо є). Директорія `data/` повинна бути включена у `.gitignore` для запобігання коміту чутливих даних у Git. Дані повинні зберігатися на окремому сервері або у хмарному сховищі для безпеки.

**Як робити snapshot** — snapshot (знімок стану) системи виконується через: копіювання файлу БД у timestamp-названий файл (наприклад, `app_20240101_120000.db`), копіювання всіх файлів у директорії `data/`, збереження конфігураційних файлів (`.env`, `configs/`), створення архіву всіх файлів для зручності. Snapshot дозволяє відновити систему до конкретного стану.

**Відновлення** — відновлення системи виконується через: відновлення файлу БД з backup, відновлення файлів з директорії `data/`, відновлення конфігураційних файлів, перевірка цілісності даних після відновлення, тестування системи для переконання, що все працює коректно. Відновлення забезпечує, що система може бути відновлена при втраті даних.

**Міграції** — міграції БД виконуються через функцію `migrate_add_missing_columns()`, яка додає відсутні колонки до існуючих таблиць: автоматичне виконання міграцій при старті додатку, додавання нових колонок без втрати даних, перевірка наявності колонок перед додаванням. В майбутньому можна додати систему міграцій (наприклад, Alembic) для більш складних змін схеми.

## 22. Логування та моніторинг

Логування та моніторинг забезпечують відстеження роботи системи та діагностику проблем.

### 22.1. Логи бекенда

Логи бекенда записують інформацію про роботу API, обробку запитів та помилки.

**Успішні запити** — успішні запити логуються для відстеження активності: час запиту, URL, метод HTTP, статус-код, час обробки, користувач (якщо автентифікований). Логування успішних запитів дозволяє відстежувати навантаження системи, популярні ендпоінти, піки активності.

**Помилки** — помилки логуються для діагностики проблем: час помилки, URL, метод HTTP, статус-код, текст помилки, stack trace, контекст (користувач, дані запиту). Логування помилок дозволяє швидко виявити та виправити проблеми.

**Важливі події** — важливі події логуються для відстеження критичних операцій: створення користувачів, зміна паролів, блокування користувачів, генерація прогнозів, помилки БД, помилки ML. Логування важливих подій дозволяє відстежувати безпеку та стабільність системи.

### 22.2. Логи ML

Логи ML записують інформацію про роботу ML-моделей та прогнозування.

**Прогнозування** — прогнозування логуються для відстеження використання моделей: час прогнозування, використана модель, цільова змінна, вхідні параметри, результат (ймовірність, категорія ризику), час обробки. Логування прогнозування дозволяє відстежувати популярність моделей, якість передбачень, продуктивність.

**Метадані** — метадані моделей логуються для відстеження версій та якості: версія моделі, дата навчання, метрики якості, час завантаження, помилки завантаження. Логування метаданих дозволяє відстежувати зміни моделей та їх вплив на якість.

### 22.3. Моніторинг статусу системи

Моніторинг статусу системи забезпечує відстеження доступності компонентів.

**API** — моніторинг API виконується через ендпоінт `/health`, який перевіряє доступність API, версію, кількість маршрутів. Статус відображається на сторінці `/api-status` з індикаторами онлайн/офлайн.

**DB** — моніторинг БД виконується через ендпоінт `/system/database/stats`, який перевіряє доступність БД, кількість записів, розмір, активність. Статус відображається на сторінці `/api-status` з детальною статистикою.

**Ollama** — моніторинг Ollama виконується через ендпоінт `/assistant/health`, який перевіряє доступність Ollama, латентність, помилки. Статус відображається на сторінці `/api-status` з індикаторами та графіками латентності.

**Перевірка доступності** — перевірка доступності виконується періодично (кожні 10 секунд) через автоматичні запити до ендпоінтів статусів. Результати зберігаються у пам'яті для побудови графіків та аналізу трендів.

## 23. Масштабування

Масштабування забезпечує можливість розширення системи для обробки більшої кількості користувачів та даних.

**Винос БД у PostgreSQL** — перехід з SQLite на PostgreSQL забезпечує кращу продуктивність та масштабованість: підтримка одночасних запитів, краща продуктивність для великих обсягів даних, підтримка реплікації та шардінгу, кращі інструменти для моніторингу та оптимізації. Перехід виконується через зміну connection string у `.env` та міграцію даних з SQLite у PostgreSQL.

**Перенесення models у окремий microservice** — винесення ML-моделей у окремий мікросервіс забезпечує: незалежне масштабування ML-компонентів, використання GPU для швидшого інференсу, ізоляцію ML-коду від основного API, можливість використання різних мов програмування для ML. Мікросервіс комунікує з основним API через REST API або gRPC.

**Горизонтальне масштабування API** — горизонтальне масштабування API забезпечує обробку більшої кількості запитів: запуск кількох інстансів API на різних серверах, використання load balancer для розподілу навантаження, використання shared БД для синхронізації даних, використання Redis для кешування та сесій. Горизонтальне масштабування дозволяє обробляти тисячі одночасних користувачів.

**CDN для статичних файлів** — використання CDN для статичних файлів забезпечує швидке завантаження: розподіл статичних файлів (CSS, JS, шрифти, зображення) по серверах у різних регіонах, кешування файлів на CDN для швидкого доступу, зменшення навантаження на основний сервер. CDN забезпечує швидке завантаження сторінок для користувачів з різних регіонів.

**GPU inference для ML** — використання GPU для ML inference забезпечує швидший інференс: обробка тисяч прогнозів одночасно, зменшення часу обробки з секунд до мілісекунд, можливість використання складніших моделей, економія CPU ресурсів для інших компонентів. GPU inference особливо важливий для великих моделей та високого навантаження.

## 24. Висновок

Система HealthRisk.AI є комплексним рішенням для оцінки ризиків здоров'я на основі машинного навчання, яке об'єднує наукові дослідження, технологічну реалізацію та користувацький досвід у єдину систему.

**Що система робить** — система HealthRisk.AI надає користувачам можливість оцінити ризики розвитку діабету та ожиріння на основі їх медичних параметрів (вік, стать, ІМТ, артеріальний тиск, глюкоза, холестерин). Система використовує навчені ML-моделі для прогнозування ймовірності ризику, надає детальну інформацію про фактори впливу, генерує візуальні звіти у форматі PDF, надає AI-асистента для пояснення результатів та рекомендацій. Система працює як веб-додаток з повною функціональністю для реєстрації користувачів, збереження історії прогнозів, спілкування з іншими користувачами та отримання персоналізованих рекомендацій.

**Чому корисна** — система корисна для кількох груп користувачів: звичайні користувачі отримують швидку оцінку своїх ризиків здоров'я без необхідності консультації з лікарем, лікарі можуть використовувати систему як допоміжний інструмент для оцінки ризиків пацієнтів, дослідники можуть використовувати систему для аналізу даних та покращення моделей, студенти можуть використовувати систему для навчання ML та медичної інформатики. Система надає прозорість у процесі оцінки ризиків через пояснення факторів впливу та метадані моделей, що забезпечує довіру користувачів.

**Що реалізовано** — система реалізує повний цикл від сирих даних до вебінтерфейсу: ETL-процес для обробки NHANES датасету, EDA для аналізу даних та вибору ознак, навчання ML-моделей для прогнозування ризиків, калібрування моделей для реалістичних ймовірностей, FastAPI бекенд для обробки запитів та ML inference, SQLite база даних для збереження даних, SPA фронтенд для взаємодії користувачів, генерація PDF-звітів з діаграмами, AI-асистент на основі Ollama для персоналізованих рекомендацій, система чатів між користувачами, моніторинг статусу системи, інтернаціоналізація (українська та англійська мови), система тестування для забезпечення якості. Всі компоненти інтегровані та працюють разом для створення повнофункціональної системи.

**Які можливості для майбутнього** — система має великий потенціал для розвитку: додавання нових ризиків (серцево-судинні захворювання, онкологія, інші), покращення точності моделей через більші датасети та нові алгоритми, додавання нових функцій (нагадування, моніторинг показників у часі, інтеграція з медичними пристроями), перехід на хмарну інфраструктуру для масштабування, додавання мобільного додатку для зручності користувачів, інтеграція з електронними медичними картками, додавання функцій телемедицини, покращення AI-асистента через більші моделі та RAG (Retrieval-Augmented Generation). Система може стати основою для комерційного продукту або продовження наукових досліджень.

**Чому це завершена дипломна робота високого рівня** — проєкт HealthRisk.AI демонструє високий рівень технічної реалізації та наукового підходу: комплексність — система охоплює повний цикл від даних до вебінтерфейсу, включаючи ETL, EDA, ML, API, фронтенд, БД, AI, тестування, технічна складність — використання сучасних технологій (FastAPI, SQLModel, Chart.js, jsPDF, Ollama) та архітектурних підходів (SPA, REST API, ORM, мікросервіси), наукова обґрунтованість — використання офіційного медичного датасету (NHANES), науковий підхід до вибору ознак та навчання моделей, калібрування для реалістичних ймовірностей, практична корисність — система може бути використана реальними користувачами для оцінки ризиків здоров'я, надає конкретні результати та рекомендації, документація — повна технічна документація українською мовою, що описує всі аспекти системи, тестування — система тестування забезпечує якість та стабільність коду, масштабованість — архітектура дозволяє легко масштабувати систему для більшої кількості користувачів. Проєкт демонструє професійний підхід до розробки, глибоке розуміння технологій та здатність створювати складні системи, що робить його завершеною дипломною роботою високого рівня, яка може бути використана як основа для подальших досліджень або комерційного продукту.

